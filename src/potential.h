
namespace sirius {

// generated by the following Mathematica expression: 
//     Do[Print[Table[CForm[N[ Gamma[5/2+l+n]/ Gamma[3/2+l],20]],{n,0,10}],","],{l,0,30}]
const double gamma_factors[31][11] = {
{1.5,3.75,13.125,59.0625,324.84375,2111.484375,15836.1328125,134607.12890625,1.278767724609375e6,1.34270611083984375e7,1.5441120274658203125e8},
{2.5,8.75,39.375,216.5625,1407.65625,10557.421875,89738.0859375,852511.81640625,8.951374072265625e6,1.029408018310546875e8,1.2867600228881835938e9},
{3.5,15.75,86.625,563.0625,4222.96875,35895.234375,341004.7265625,3.58054962890625e6,4.1176320732421875e7,5.147040091552734375e8,6.9485041235961914062e9},
{4.5,24.75,160.875,1206.5625,10255.78125,97429.921875,1.0230141796875e6,1.176466306640625e7,1.47058288330078125e8,1.9852868924560546875e9,2.8786659940612792969e10},
{5.5,35.75,268.125,2279.0625,21651.09375,227336.484375,2.6143695703125e6,3.267961962890625e7,4.41174864990234375e8,6.3970355423583984375e9,9.9154050906555175781e10},
{6.5,48.75,414.375,3936.5625,41333.90625,475339.921875,5.9417490234375e6,8.021361181640625e7,1.163097371337890625e9,1.8028009255737304687e10,2.9746215271966552734e11},
{7.5,63.75,605.625,6359.0625,73129.21875,914115.234375,1.23405556640625e7,1.7893805712890625e8,2.773539885498046875e9,4.5763408110717773438e10,8.0085964193756103516e11},
{8.5,80.75,847.875,9750.5625,121882.03125,1.645407421875e6,2.38584076171875e7,3.6980531806640625e8,6.101787748095703125e9,1.0678128559167480469e11,1.9754537834459838867e12},
{9.5,99.75,1147.125,14339.0625,193577.34375,2.806871484375e6,4.35065080078125e7,7.1785738212890625e8,1.2562504187255859375e10,2.3240632746423339844e11,4.5319233855525512695e12},
{10.5,120.75,1509.375,20376.5625,295460.15625,4.579632421875e6,7.55639349609375e7,1.32236886181640625e9,2.4463823943603515625e10,4.7704456690026855469e11,9.7794136214555053711e12},
{11.5,143.75,1940.625,28139.0625,436155.46875,7.196565234375e6,1.259398916015625e8,2.32988799462890625e9,4.5432815895263671875e10,9.3137272585290527344e11,2.0024513605837463379e13},
{12.5,168.75,2446.875,37926.5625,625788.28125,1.0951294921875e7,2.025989560546875e8,3.95067964306640625e9,8.0988932682861328125e10,1.7412620526815185547e12,3.917839618533416748e13},
{13.5,195.75,3034.125,50063.0625,876103.59375,1.6207916484375e7,3.160543714453125e8,6.47911461462890625e9,1.3930096421452148438e11,3.1342716948267333984e12,7.3655384828428234863e13},
{14.5,224.75,3708.375,64896.5625,1.20058640625e6,2.3411434921875e7,4.799344158984375e8,1.031858994181640625e10,2.3216827369086914063e11,5.4559544317354248047e12,1.3367088357751790771e14},
{15.5,255.75,4475.625,82799.0625,1.61458171875e6,3.3098925234375e7,7.116268925390625e8,1.601160508212890625e10,3.7627271943002929687e11,9.2186816260357177734e12,2.3507638146391080322e14},
{16.5,288.75,5341.875,104166.5625,2.13541453125e6,4.5911412421875e7,1.0330067794921875e9,2.427565931806640625e10,5.9475365329262695312e11,1.5166218158961987305e13,4.0190478121249266357e14},
{17.5,323.75,6313.125,129419.0625,2.78250984375e6,6.2606471484375e7,1.4712520798828125e9,3.604567595712890625e10,9.1916473690678710938e11,2.4357865528029858398e13,6.6984130202082110596e14},
{18.5,360.75,7395.375,159000.5625,3.57751265625e6,8.4071547421875e7,2.0597529118359375e9,5.252369925181640625e10,1.3918780301731347656e12,3.8276645829761206055e13,1.0908844061481943726e15},
{19.5,399.75,8594.625,193379.0625,4.54440796875e6,1.11337995234375e8,2.8391188784765625e9,7.523665027962890625e10,2.0690078826897949219e12,5.8966724656659155273e13,1.7395183773714450806e15},
{20.5,440.75,9916.875,233046.5625,5.70964078125e6,1.45595839921875e8,3.8582897579296875e9,1.0610296834306640625e11,3.0239345977773925781e12,8.9206070634433081055e13,2.7207851543502089722e15},
{21.5,483.75,11368.125,278519.0625,7.10223609375e6,1.88209256484375e8,5.1757545533203125e9,1.4750900476962890625e11,4.3515156407040527344e12,1.327212270414736084e14,4.1807186518064186646e15},
{22.5,528.75,12954.375,330336.5625,8.75391890625e6,2.40732769921875e8,6.8608839427734375e9,2.0239607631181640625e11,6.1730803275104003906e12,1.944520303165776123e14,6.3196909852887723999e15},
{23.5,575.75,14681.625,389063.0625,1.069923421875e7,3.04928175234375e8,8.9953811694140625e9,2.7435912566712890625e11,8.6423124585145605469e12,2.8087515490172321777e14,9.4093176892077277954e15},
{24.5,624.75,16555.875,455286.5625,1.297566703125e7,3.82782177421875e8,1.16748564113671875e10,3.6775797695806640625e11,1.1952134251137158203e13,4.003964974130947998e14,1.3813679160751770593e16},
{25.5,675.75,18583.125,529619.0625,1.562376234375e7,4.76524751484375e8,1.50105296717578125e10,4.8784221433212890625e11,1.6342714180126318359e13,5.638236392143579834e14,2.0015739192109708411e16},
{26.5,728.75,20769.375,612696.5625,1.868724515625e7,5.88648222421875e8,1.91310672287109375e10,6.4089075216181640625e11,2.2110730949582666016e13,7.8493094871018464355e14,2.864997962792173949e16},
{27.5,783.75,23120.625,705179.0625,2.221314046875e7,7.21927065234375e8,2.41845566853515625e10,8.3436720564462890625e11,2.9620035800384326172e13,1.0811313067140279053e15,4.0542424001776046448e16},
{28.5,840.75,25642.875,807750.5625,2.625189328125e7,8.79438424921875e8,3.03406256598046875e10,1.0770922109230664062e12,3.9313865698691923828e13,1.4742699637009471436e15,5.6759393602486465027e16},
{29.5,899.75,28342.125,921119.0625,3.085748859375e7,1.064583356484375e9,3.77927091551953125e10,1.3794338841646289062e12,5.1728770656173583984e13,1.9915576702626829834e15,7.8666527975375977844e16},
{30.5,960.75,31224.375,1.0460165625e6,3.608757140625e7,1.281108784921875e9,4.67604706496484375e10,1.7535176493618164062e12,6.7510429500429931641e13,2.6666619652669822998e15,1.0799980959331278314e17},
{31.5,1023.75,34295.625,1.1831990625e6,4.200356671875e7,1.533130185234375e9,5.74923819462890625e10,2.2134567049321289062e12,8.7431539844819091797e13,3.5409773637151732178e15,1.4695056059417968854e17}};

/*! 
    \brief Generate effective potential from charge density and magnetization
   
*/
class Potential 
{
    private:
        
        Global& parameters_;

        int allocate_f_;
        
        PeriodicFunction<double>* effective_potential_;
        
        PeriodicFunction<double>* effective_magnetic_field_[3];
 
        mdarray<complex16,2> gvec_ylm_;

        mdarray<double,3> sbessel_mom_;

        mdarray<double,3> sbessel_mt_;
        
        SHT sht_;

        int pseudo_density_order;

        /// G-vector phase factors
        mdarray<complex16, 2> gvec_phase_factors_;
        
        /// splitted G-vector index
        splindex<block> spl_num_gvec_;

        std::vector<complex16> zil_;
        
        std::vector<complex16> zilm_;

        std::vector<int> l_by_lm_;
        
        /// Compute MT part of the potential and MT multipole moments
        
        /**
            \note MPI reduction may not be efficient on many ranks; consider single node implementation
        */
        void poisson_vmt(PeriodicFunction<double>* rho, PeriodicFunction<double>* vh, splindex<block>& spl_num_atoms,
                         mdarray<complex16, 2>& qmt)
        {
            Timer t("sirius::Potential::poisson:vmt");

            vh->zero(ylm_component);
            qmt.zero();
            
            for (int ialoc = 0; ialoc < spl_num_atoms.local_size(); ialoc++)
            {
                int ia = spl_num_atoms[ialoc];

                double R = parameters_.atom(ia)->type()->mt_radius();
                int nmtp = parameters_.atom(ia)->type()->num_mt_points();
               
                #pragma omp parallel default(shared)
                {
                    std::vector<complex16> g1;
                    std::vector<complex16> g2;
   
                    Spline<complex16> rholm(nmtp, parameters_.atom(ia)->type()->radial_grid());

                    #pragma omp for
                    for (int lm = 0; lm < parameters_.lmmax_rho(); lm++)
                    {
                        int l = l_by_lm_[lm];

                        for (int ir = 0; ir < nmtp; ir++)
                            rholm[ir] = rho->f_ylm(lm, ir, ia);
                        rholm.interpolate();

                        // save multipole moment
                        qmt(lm, ia) = rholm.integrate(g1, l + 2);
                        
                        if (lm < parameters_.lmmax_pot())
                        {
                            rholm.integrate(g2, 1 - l);
                            
                            double d1 = 1.0 / pow(R, 2 * l + 1); 
                            double d2 = 1.0 / double(2 * l + 1); 
                            for (int ir = 0; ir < nmtp; ir++)
                            {
                                double r = parameters_.atom(ia)->type()->radial_grid(ir);

                                complex16 vlm = (1.0 - pow(r / R, 2 * l + 1)) * g1[ir] / pow(r, l + 1) +
                                                (g2[nmtp - 1] - g2[ir]) * pow(r, l) - 
                                                (g1[nmtp - 1] - g1[ir]) * pow(r, l) * d1;

                                vh->f_ylm(lm, ir, ia) = fourpi * vlm * d2;
                            }
                        }
                    }
                }
                
                // nuclear potential
                for (int ir = 0; ir < nmtp; ir++)
                {
                    double r = parameters_.atom(ia)->type()->radial_grid(ir);
                    vh->f_ylm(0, ir, ia) -= fourpi * y00 * parameters_.atom(ia)->type()->zn() * 
                                                           (1.0 / r - 1.0 / R);
                }

                // nuclear multipole moment
                qmt(0, ia) -= parameters_.atom(ia)->type()->zn() * y00;
            }

            Platform::allreduce(&qmt(0, 0), (int)qmt.size());
        }


        /// Compute multipole momenst of the interstitial charge density

        /** Also, compute the MT boundary condition 
            
        */
        void poisson_sum_G(complex16* fpw, mdarray<double, 3>& fl, mdarray<complex16, 2>& flm)
        {
            Timer t("sirius::Potential::poisson_sum_G");
            
            flm.zero();

            mdarray<complex16, 2> zm1(spl_num_gvec_.local_size(), parameters_.lmmax_rho());

            #pragma omp parallel for default(shared)
            for (int lm = 0; lm < parameters_.lmmax_rho(); lm++)
                for (int igloc = 0; igloc < spl_num_gvec_.local_size(); igloc++)
                    zm1(igloc, lm) = gvec_ylm_(lm, igloc) * conj(fpw[spl_num_gvec_[igloc]] * zilm_[lm]);

            mdarray<complex16, 2> zm2(spl_num_gvec_.local_size(), parameters_.num_atoms());

            for (int l = 0; l <= parameters_.lmax_rho(); l++)
            {
                #pragma omp parallel for default(shared)
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                {
                    int iat = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());
                    for (int igloc = 0; igloc < spl_num_gvec_.local_size(); igloc++)
                        zm2(igloc, ia) = fourpi * gvec_phase_factors_(igloc, ia) *  
                                         fl(l, iat, parameters_.gvec_shell(spl_num_gvec_[igloc]));
                }

                gemm<cpu>(2, 0, 2 * l + 1, parameters_.num_atoms(), spl_num_gvec_.local_size(), complex16(1, 0), 
                          &zm1(0, Utils::lm_by_l_m(l, -l)), zm1.ld(), &zm2(0, 0), zm2.ld(), complex16(0, 0), 
                          &flm(Utils::lm_by_l_m(l, -l), 0), parameters_.lmmax_rho());
            }
            
            Platform::allreduce(&flm(0, 0), (int)flm.size());
        }

        /// Compute contribution from the pseudocharge to the plane-wave expansion
        void poisson_pw(mdarray<complex16, 2>& qmt, mdarray<complex16, 2>& qit, complex16* pseudo_pw)
        {
            Timer t("sirius::Potential::poisson_pw");
            memset(pseudo_pw, 0, parameters_.num_gvec() * sizeof(complex16));
            
            // 
            // The following term is added to the plane-wave coefficients of the charge density:
            // Integrate[SphericalBesselJ[l,a*x]*p[x,R]*x^2,{x,0,R},Assumptions->{l>=0,n>=0,R>0,a>0}] / 
            //   Integrate[p[x,R]*x^(2+l),{x,0,R},Assumptions->{h>=0,n>=0,R>0}]
            // i.e. contributon from pseudodensity to l-th channel of plane wave expansion multiplied by 
            // the difference bethween true and interstitial-in-the-mt multipole moments and divided by the 
            // moment of the pseudodensity
            
            // precompute R^(-l)
            mdarray<double, 2> Rl(parameters_.lmax_rho() + 1, parameters_.num_atom_types());
            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
                for (int l = 0; l <= parameters_.lmax_rho(); l++)
                    Rl(l, iat) = pow(parameters_.atom_type(iat)->mt_radius(), -l);

            #pragma omp parallel default(shared)
            {
                std::vector<complex16> pseudo_pw_pt(parameters_.num_gvec(), complex16(0, 0));

                #pragma omp for
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                {
                    int iat = parameters_.atom_type_index_by_id(parameters_.atom(ia)->type_id());

                    double R = parameters_.atom(ia)->type()->mt_radius();

                    // compute G-vector independent prefactor
                    std::vector<complex16> zp(parameters_.lmmax_rho());
                    for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
                        for (int m = -l; m <= l; m++, lm++)
                            zp[lm] = (qmt(lm, ia) - qit(lm, ia)) * Rl(l, iat) * conj(zil_[l]) *
                                     gamma_factors[l][pseudo_density_order]; 

                    for (int igloc = 0; igloc < spl_num_gvec_.local_size(); igloc++)
                    {
                        int ig = spl_num_gvec_[igloc];
                        
                        double gR = parameters_.gvec_len(ig) * R;
                        
                        complex16 zt = fourpi * conj(gvec_phase_factors_(igloc, ia)) / parameters_.omega();

                        // TODO: add to documentation
                        // (2^(1/2+n) Sqrt[\[Pi]] R^-l (a R)^(-(3/2)-n) BesselJ[3/2+l+n,a R] * 
                        //   Gamma[5/2+l+n])/Gamma[3/2+l] and BesselJ is expressed in terms of SphericalBesselJ
                        if (ig)
                        {
                            complex16 zt2(0, 0);
                            for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
                            {
                                complex16 zt1(0, 0);
                                for (int m = -l; m <= l; m++, lm++)
                                    zt1 += gvec_ylm_(lm, igloc) * zp[lm];

                                zt2 += zt1 * sbessel_mt_(l + pseudo_density_order + 1, iat, parameters_.gvec_shell(ig));
                            }

                            pseudo_pw_pt[ig] += zt * zt2 * pow(2.0 / gR, pseudo_density_order + 1);
                        }
                        else // for |G|=0
                            pseudo_pw_pt[ig] += zt * y00 * (qmt(0, ia) - qit(0, ia));
                    }
                }
                #pragma omp critical
                for (int ig = 0; ig < parameters_.num_gvec(); ig++)
                    pseudo_pw[ig] += pseudo_pw_pt[ig];
            }

            Platform::allreduce(&pseudo_pw[0], parameters_.num_gvec());
        }

        /*! \brief Poisson solver
            
            plane wave expansion
            \f[
                e^{i{\bf g}{\bf r}}=4\pi e^{i{\bf g}{\bf r}_{\alpha}} \sum_{\ell m} i^\ell 
                    j_{\ell}(g|{\bf r}-{\bf r}_{\alpha}|)
                    Y_{\ell m}^{*}({\bf \hat g}) Y_{\ell m}(\widehat{{\bf r}-{\bf r}_{\alpha}})
            \f]

            Multipole moment:
            \f[
                q_{\ell m} = \int Y_{\ell m}^{*}(\hat {\bf r}) r^l \rho({\bf r}) d {\bf r}

            \f]

            Spherical Bessel function moments
            \f[
                \int_0^R j_{\ell}(a x)x^{2+\ell} dx = \frac{\sqrt{\frac{\pi }{2}} R^{\ell+\frac{3}{2}} 
                    J_{\ell+\frac{3}{2}}(a R)}{a^{3/2}}
            \f]
            for a = 0 the integral is \f$ \frac{R^3}{3} \delta_{\ell,0} \f$

            General solution to the Poisson equation with spherical boundary condition:
            \f[
                V({\bf x}) = \int \rho({\bf x'})G({\bf x},{\bf x'}) d{\bf x'} - \frac{1}{4 \pi} \int_{S} V({\bf x'}) 
                    \frac{\partial G}{\partial n'} d{\bf S'}
            \f]

            Green's function for a sphere
            \f[
                G({\bf x},{\bf x'}) = 4\pi \sum_{\ell m} \frac{Y_{\ell m}^{*}(\hat {\bf x'}) 
                    Y_{\ell m}(\hat {\bf x})}{2\ell + 1}
                    \frac{r_{<}^{\ell}}{r_{>}^{\ell+1}}\Biggl(1 - \Big( \frac{r_{>}}{R} \Big)^{2\ell + 1} \Biggr)
            \f]

            Pseudodensity radial functions:
            \f[
                p_{\ell}(r) = r^{\ell} \left(1-\frac{r^2}{R^2}\right)^n
            \f]
            where n is the order of pseudo density.

        */
        void poisson(PeriodicFunction<double>* rho, PeriodicFunction<double>* hartree_potential)
        {
            Timer t("sirius::Potential::poisson");

            splindex<block> spl_num_atoms(parameters_.num_atoms(), Platform::num_mpi_ranks(), Platform::mpi_rank());
            
            // true multipole moments
            mdarray<complex16,2> qmt(parameters_.lmmax_rho(), parameters_.num_atoms());
            poisson_vmt(rho, hartree_potential, spl_num_atoms, qmt);

            // compute multipoles of interstitial density in MT region
            mdarray<complex16, 2> qit(parameters_.lmmax_rho(), parameters_.num_atoms());
            poisson_sum_G(rho->f_pw(), sbessel_mom_, qit);
            
            // compute contribution from the pseudo-charge
            std::vector<complex16> pseudo_pw(parameters_.num_gvec());
            poisson_pw(qmt, qit, &pseudo_pw[0]);

            for (int ig = 0; ig < parameters_.num_gvec(); ig++) pseudo_pw[ig] += rho->f_pw(ig); 
            
            if (check_pseudo_charge)
            {
                poisson_sum_G(&pseudo_pw[0], sbessel_mom_, qit);

                double d = 0.0;
                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                    for (int lm = 0; lm < parameters_.lmmax_rho(); lm++)
                        d += abs(qmt(lm, ia) - qit(lm, ia));

                parameters_.rti().pseudo_charge_error = d;
            }
            else
            {
                parameters_.rti().pseudo_charge_error = 0.0;
            }
 
            // compute pw coefficients of Hartree potential
            pseudo_pw[0] = 0.0;
            hartree_potential->f_pw(0) = 0.0;
            for (int ig = 1; ig < parameters_.num_gvec(); ig++)
                hartree_potential->f_pw(ig) = pseudo_pw[ig] * fourpi / pow(parameters_.gvec_len(ig), 2);

            // compute V_lm at the MT boundary
            mdarray<complex16, 2> vmtlm(parameters_.lmmax_pot(), parameters_.num_atoms());
            poisson_sum_G(hartree_potential->f_pw(), sbessel_mt_, vmtlm);
            
            // add boundary condition
            Timer* t1 = new Timer("sirius::Potential::poisson:bc");
            mdarray<double, 2> rRl(parameters_.max_num_mt_points(), parameters_.lmax_pot() + 1);
            int type_id_prev = -1;

            for (int ialoc = 0; ialoc < spl_num_atoms.local_size(); ialoc++)
            {
                int ia = spl_num_atoms[ialoc];

                if (parameters_.atom(ia)->type_id() != type_id_prev)
                {
                    type_id_prev = parameters_.atom(ia)->type_id();
                
                    double R = parameters_.atom(ia)->type()->mt_radius();

                    #pragma omp parallel for default(shared)
                    for (int l = 0; l <= parameters_.lmax_pot(); l++)
                    {
                        for (int ir = 0; ir < parameters_.atom(ia)->type()->num_mt_points(); ir++)
                            rRl(ir, l) = pow(parameters_.atom(ia)->type()->radial_grid(ir) / R, l);
                    }
                }

                #pragma omp parallel for default(shared)
                for (int lm = 0; lm < parameters_.lmmax_pot(); lm++)
                {
                    int l = l_by_lm_[lm];

                    for (int ir = 0; ir < parameters_.atom(ia)->type()->num_mt_points(); ir++)
                        hartree_potential->f_ylm(lm, ir, ia) += vmtlm(lm, ia) * rRl(ir, l);
                }
            }
            delete t1;
           
            // sync MT part of Hartree potential after adding a boundary condition
            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                Platform::allreduce(&hartree_potential->f_ylm(0, 0, ia), 
                                    parameters_.lmmax_pot() * parameters_.max_num_mt_points());
            }
            
            hartree_potential->convert_to_rlm();

            parameters_.fft().input(parameters_.num_gvec(), parameters_.fft_index(), hartree_potential->f_pw());
            parameters_.fft().transform(1);
            parameters_.fft().output(hartree_potential->f_it());
        }

        void xc(PeriodicFunction<double>* rho, PeriodicFunction<double>* magnetization[3], 
                PeriodicFunction<double>* xc_potential, PeriodicFunction<double>* xc_magnetic_field[3], 
                PeriodicFunction<double>* xc_energy_density)
        {
            Timer t("sirius::Potential::xc");
            
            splindex<block> spl_num_atoms(parameters_.num_atoms(), Platform::num_mpi_ranks(), Platform::mpi_rank());
            
            mdarray<double,2> rhotp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double,2> vxctp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double,2> exctp(sht_.num_points(), parameters_.max_num_mt_points());
            
            mdarray<double,3> vecmagtp(sht_.num_points(), parameters_.max_num_mt_points(), parameters_.num_mag_dims());
            mdarray<double,2> magtp(sht_.num_points(), parameters_.max_num_mt_points());
            mdarray<double,3> vecbxctp(sht_.num_points(), parameters_.max_num_mt_points(), parameters_.num_mag_dims());
            mdarray<double,2> bxctp(sht_.num_points(), parameters_.max_num_mt_points());

            xc_potential->zero(rlm_component);
            xc_energy_density->zero(rlm_component);
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                xc_magnetic_field[j]->zero(rlm_component);

            for (int ialoc = 0; ialoc < spl_num_atoms.local_size(); ialoc++)
            {
                int ia = spl_num_atoms[ialoc];
                int nmtp = parameters_.atom(ia)->type()->num_mt_points();

                sht_.rlm_backward_transform(&rho->f_rlm(0, 0, ia), parameters_.lmmax_rho(), nmtp, &rhotp(0, 0));

                if (parameters_.num_spins() == 2)
                {
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                        sht_.rlm_backward_transform(&magnetization[j]->f_rlm(0, 0, ia), parameters_.lmmax_rho(), nmtp,
                                                    &vecmagtp(0, 0, j));
                    for (int ir = 0; ir < nmtp; ir++)
                        for (int itp = 0; itp < sht_.num_points(); itp++)
                        {
                            double t = 0.0;
                            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                                t += vecmagtp(itp, ir, j) *  vecmagtp(itp, ir, j);
                            magtp(itp, ir) = sqrt(t);
                        }
                }
                
                if (parameters_.num_spins() == 1) 
                    libxc_interface::getxc(sht_.num_points() * nmtp, &rhotp(0, 0), &vxctp(0, 0), &exctp(0, 0));
                else
                    libxc_interface::getxc(sht_.num_points() * nmtp, &rhotp(0, 0), &magtp(0, 0), &vxctp(0, 0), 
                                           &bxctp(0, 0), &exctp(0, 0));

                sht_.rlm_forward_transform(&vxctp(0, 0), parameters_.lmmax_pot(), nmtp, 
                                           &xc_potential->f_rlm(0, 0, ia));
                sht_.rlm_forward_transform(&exctp(0, 0), parameters_.lmmax_pot(), nmtp, 
                                           &xc_energy_density->f_rlm(0, 0, ia));

                if (parameters_.num_spins() == 2)
                {
                    vecbxctp.zero();
                    for (int ir = 0; ir < nmtp; ir++)
                        for (int itp = 0; itp < sht_.num_points(); itp++)
                            if (magtp(itp, ir) > 1e-8)
                                for (int j = 0; j < parameters_.num_mag_dims(); j++)
                                    vecbxctp(itp, ir, j) = bxctp(itp, ir) * vecmagtp(itp, ir, j) / magtp(itp, ir);
                            else
                                for (int j = 0; j < parameters_.num_mag_dims(); j++)
                                    vecbxctp(itp, ir, j) = 0.0;
                                
                    
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                        sht_.rlm_forward_transform(&vecbxctp(0, 0, j), parameters_.lmmax_pot(), nmtp,
                                                   &xc_magnetic_field[j]->f_rlm(0, 0, ia));
                }
            }
           
            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                Platform::allreduce(&xc_potential->f_rlm(0, 0, ia), 
                                    parameters_.lmmax_pot() * parameters_.max_num_mt_points()); 

                Platform::allreduce(&xc_energy_density->f_rlm(0, 0, ia), 
                                    parameters_.lmmax_pot() * parameters_.max_num_mt_points()); 
           
                for (int j = 0; j < parameters_.num_mag_dims(); j++)
                    Platform::allreduce(&xc_magnetic_field[j]->f_rlm(0, 0, ia), 
                                        parameters_.lmmax_pot() * parameters_.max_num_mt_points()); 
            }
            
            if (parameters_.num_spins() == 1)
                libxc_interface::getxc(parameters_.fft().size(), rho->f_it(), xc_potential->f_it(), 
                                       xc_energy_density->f_it());
            else
            {
                std::vector<double> magit(parameters_.fft().size());
                std::vector<double> bxcit(parameters_.fft().size());

                for (int ir = 0; ir < parameters_.fft().size(); ir++)
                {
                    double t = 0.0;
                    for (int j = 0; j < parameters_.num_mag_dims(); j++)
                        t += magnetization[j]->f_it(ir) * magnetization[j]->f_it(ir);
                    magit[ir] = sqrt(t);
                }
                libxc_interface::getxc(parameters_.fft().size(), rho->f_it(), &magit[0], xc_potential->f_it(), 
                                       &bxcit[0], xc_energy_density->f_it());
                
                for (int ir = 0; ir < parameters_.fft().size(); ir++)
                    if (magit[ir] > 1e-8)
                        for (int j = 0; j < parameters_.num_mag_dims(); j++)
                            xc_magnetic_field[j]->f_it(ir) = bxcit[ir] * magnetization[j]->f_it(ir) / magit[ir];
                    else
                        for (int j = 0; j < parameters_.num_mag_dims(); j++)
                            xc_magnetic_field[j]->f_it(ir) = 0.0;
            }
        }

    public:

        Potential(Global& parameters__, int allocate_f__ = pw_component) : parameters_(parameters__),
                                                                           allocate_f_(allocate_f__),
                                                                           pseudo_density_order(10)
        {
            Timer t("sirius::Potential::Potential");
            
            int lmax = std::max(parameters_.lmax_rho(), parameters_.lmax_pot());
            sht_.set_lmax(lmax);

            // compute values of spherical Bessel functions at MT boundary
            sbessel_mt_.set_dimensions(lmax + pseudo_density_order + 2, parameters_.num_atom_types(), 
                                       parameters_.num_gvec_shells());
            sbessel_mt_.allocate();

            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
                for (int igs = 0; igs < parameters_.num_gvec_shells(); igs++)
                    gsl_sf_bessel_jl_array(lmax + pseudo_density_order + 1, 
                                           parameters_.gvec_shell_len(igs) * parameters_.atom_type(iat)->mt_radius(), 
                                           &sbessel_mt_(0, iat, igs));

            // compute moments of spherical Bessel functions 
            // 
            // Integrate[SphericalBesselJ[l,a*x]*x^(2+l),{x,0,R},Assumptions->{R>0,a>0,l>=0}]
            // and use relation between Bessel and spherical Bessel functions: 
            //   Subscript[j, n](z)=Sqrt[\[Pi]/2]/Sqrt[z]Subscript[J, n+1/2](z)
            sbessel_mom_.set_dimensions(parameters_.lmax_rho() + 1, parameters_.num_atom_types(), 
                                        parameters_.num_gvec_shells());
            sbessel_mom_.allocate();
            sbessel_mom_.zero();

            for (int iat = 0; iat < parameters_.num_atom_types(); iat++)
            {
                sbessel_mom_(0, iat, 0) = pow(parameters_.atom_type(iat)->mt_radius(), 3) / 3.0; // for |G|=0
                for (int igs = 1; igs < parameters_.num_gvec_shells(); igs++)
                    for (int l = 0; l <= parameters_.lmax_rho(); l++)
                        sbessel_mom_(l, iat, igs) = pow(parameters_.atom_type(iat)->mt_radius(), 2 + l) * 
                                                    sbessel_mt_(l + 1, iat, igs) / parameters_.gvec_shell_len(igs);
            }

            // create splitted index
            spl_num_gvec_.split(parameters_.num_gvec(), Platform::num_mpi_ranks(), Platform::mpi_rank());

            // precompute spherical harmonics of G-vectors and G-vector phase factors
            gvec_ylm_.set_dimensions(Utils::lmmax_by_lmax(lmax), spl_num_gvec_.local_size());
            gvec_ylm_.allocate();
            
            gvec_phase_factors_.set_dimensions(spl_num_gvec_.local_size(), parameters_.num_atoms());
            gvec_phase_factors_.allocate();

            for (int igloc = 0; igloc < spl_num_gvec_.local_size(); igloc++)
            {
                int ig = spl_num_gvec_[igloc];
                double cartc[3];
                double spc[3];
                parameters_.get_coordinates<cartesian, reciprocal>(parameters_.gvec(ig), cartc);
                SHT::spherical_coordinates(cartc, spc);
                SHT::spherical_harmonics(lmax, spc[1], spc[2], &gvec_ylm_(0, igloc));

                for (int ia = 0; ia < parameters_.num_atoms(); ia++)
                    gvec_phase_factors_(igloc, ia) = parameters_.gvec_phase_factor(ig, ia);
            }

            effective_potential_ = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
            effective_potential_->allocate(allocate_f_);

            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                effective_magnetic_field_[j] = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
                effective_magnetic_field_[j]->allocate(allocate_f_);
            }
            
            // precompute i^l
            zil_.resize(parameters_.lmax_rho() + 1);
            for (int l = 0; l <= parameters_.lmax_rho(); l++)
                zil_[l] = pow(complex16(0.0, 1.0), l);
            
            zilm_.resize(parameters_.lmmax_rho());
            for (int l = 0, lm = 0; l <= parameters_.lmax_rho(); l++)
                for (int m = -l; m <= l; m++, lm++)
                    zilm_[lm] = zil_[l];

            l_by_lm_.resize(Utils::lmmax_by_lmax(lmax));
            for (int l = 0, lm = 0; l <= lmax; l++)
                for (int m = -l; m <= l; m++, lm++)
                    l_by_lm_[lm] = l;
        }

        ~Potential()
        {
            delete effective_potential_; 
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                delete effective_magnetic_field_[j];
        }

        void set_effective_potential_ptr(double* veffmt, double* veffir)
        {
            effective_potential_->set_rlm_ptr(veffmt);
            effective_potential_->set_it_ptr(veffir);
        }
        
        void set_effective_magnetic_field_ptr(double* beffmt, double* beffir)
        {
            assert(parameters_.num_spins() == 2);

            // set temporary array wrapper
            mdarray<double,4> beffmt_tmp(beffmt, parameters_.lmmax_pot(), parameters_.max_num_mt_points(), 
                                         parameters_.num_atoms(), parameters_.num_mag_dims());
            mdarray<double,2> beffir_tmp(beffir, parameters_.fft().size(), parameters_.num_mag_dims());
            
            if (parameters_.num_mag_dims() == 1)
            {
                // z
                effective_magnetic_field_[0]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 0));
                effective_magnetic_field_[0]->set_it_ptr(&beffir_tmp(0, 0));
            }
            
            if (parameters_.num_mag_dims() == 3)
            {
                // z
                effective_magnetic_field_[0]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 2));
                effective_magnetic_field_[0]->set_it_ptr(&beffir_tmp(0, 2));
                // x
                effective_magnetic_field_[1]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 0));
                effective_magnetic_field_[1]->set_it_ptr(&beffir_tmp(0, 0));
                // y
                effective_magnetic_field_[2]->set_rlm_ptr(&beffmt_tmp(0, 0, 0, 1));
                effective_magnetic_field_[2]->set_it_ptr(&beffir_tmp(0, 1));
            }
        }
         
        void zero()
        {
            effective_potential_->zero();
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                effective_magnetic_field_[j]->zero();
        }

        void generate_effective_potential(PeriodicFunction<double>* rho, PeriodicFunction<double>* magnetization[3])
        {
            Timer t("sirius::Potential::generate_effective_potential");
            
            // zero effective potential and magnetic field
            zero();

            // get plane-wave coefficients of the charge density
            parameters_.fft().input(rho->f_it());
            parameters_.fft().transform(-1);
            parameters_.fft().output(parameters_.num_gvec(), parameters_.fft_index(), rho->f_pw());
            
            // convert charge density to Ylm expansion
            rho->allocate(ylm_component);
            rho->convert_to_ylm();

            //
            // Hartree potential
            //

            // allocate Hartree potential
            PeriodicFunction<double>* hartree_potential = new PeriodicFunction<double>(parameters_,
                                                                                       parameters_.lmax_pot());
            hartree_potential->allocate();

            // solve Poisson equation
            poisson(rho, hartree_potential);
            
            // add Hartree potential to the total potential
            effective_potential_->add(hartree_potential, rlm_component | it_component);

            // compute <rho | V_H>
            parameters_.rti().energy_vha = rho->inner<rlm_component | it_component>(hartree_potential);
            
            // compute Eenuc
            double enuc = 0.0;
            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                int zn = parameters_.atom(ia)->type()->zn();
                double r0 = parameters_.atom(ia)->type()->radial_grid(0);
                enuc -= 0.5 * zn * (hartree_potential->f_rlm(0, 0, ia) * y00 + zn / r0);
            }
            parameters_.rti().energy_enuc = enuc;

            delete hartree_potential;

            rho->deallocate(ylm_component);

            //
            // XC potential and field
            //

            // allocate functions
            PeriodicFunction<double>* xc_potential = new PeriodicFunction<double>(parameters_, 
                                                                                  parameters_.lmax_pot());
            xc_potential->allocate(rlm_component | it_component);
            
            PeriodicFunction<double>* xc_magnetic_field[3];
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                xc_magnetic_field[j] = new PeriodicFunction<double>(parameters_, parameters_.lmax_pot());
                xc_magnetic_field[j]->allocate(rlm_component | it_component);
            }
         
            PeriodicFunction<double>* xc_energy_density = new PeriodicFunction<double>(parameters_,
                                                                                       parameters_.lmax_pot());     
            xc_energy_density->allocate(rlm_component | it_component);

            xc(rho, magnetization, xc_potential, xc_magnetic_field, xc_energy_density);
            
            effective_potential_->add(xc_potential, rlm_component | it_component);

            parameters_.rti().energy_veff = rho->inner<rlm_component | it_component>(effective_potential_);
            parameters_.rti().energy_vxc = rho->inner<rlm_component | it_component>(xc_potential);
            parameters_.rti().energy_exc = rho->inner<rlm_component | it_component>(xc_energy_density);

            double ebxc = 0.0;
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                ebxc += magnetization[j]->inner<rlm_component | it_component>(xc_magnetic_field[j]);
            parameters_.rti().energy_bxc = ebxc;

            delete xc_potential;

            for (int j = 0; j < parameters_.num_mag_dims(); j++)
            {
                effective_magnetic_field_[j]->add(xc_magnetic_field[j], rlm_component | it_component);
                delete xc_magnetic_field[j];
            }
            
            delete xc_energy_density;
           
            if (Platform::mpi_rank() == 0)
            {
                hdf5_tree fout("sirius.h5", true);
                effective_potential_->hdf5_write(fout.create_node("effective_potential"));
                fout.create_node("effective_magnetic_field");
                for (int j = 0; j < parameters_.num_mag_dims(); j++)
                    effective_magnetic_field_[j]->hdf5_write(fout["effective_magnetic_field"].create_node(j));
            }
        }

        void hdf5_read()
        {
            hdf5_tree fout("sirius.h5");
            effective_potential_->hdf5_read(fout["effective_potential"]);
            for (int j = 0; j < parameters_.num_mag_dims(); j++)
                effective_magnetic_field_[j]->hdf5_read(fout["effective_magnetic_field"][j]);
        }
        
        void set_spherical_potential()
        {
            for (int ic = 0; ic < parameters_.num_atom_symmetry_classes(); ic++)
            {
               int ia = parameters_.atom_symmetry_class(ic)->atom_id(0);
               int nmtp = parameters_.atom(ia)->type()->num_mt_points();
               
               std::vector<double> veff(nmtp);
               
               for (int ir = 0; ir < nmtp; ir++)
                   veff[ir] = y00 * effective_potential_->f_rlm(0, ir, ia);

               parameters_.atom_symmetry_class(ic)->set_spherical_potential(veff);
            }
        }

        void set_nonspherical_potential()
        {
            for (int ia = 0; ia < parameters_.num_atoms(); ia++)
            {
                double* veff = &effective_potential_->f_rlm(0, 0, ia);
                
                double* beff[] = {NULL, NULL, NULL};
                for (int i = 0; i < parameters_.num_mag_dims(); i++)
                    beff[i] = &effective_magnetic_field_[i]->f_rlm(0, 0, ia);
                
                parameters_.atom(ia)->set_nonspherical_potential(veff, beff);
            }
        }

        PeriodicFunction<double>* effective_potential()
        {
            return effective_potential_;
        }

        PeriodicFunction<double>** effective_magnetic_field()
        {
            return effective_magnetic_field_;
        }
        
        PeriodicFunction<double>* effective_magnetic_field(int i)
        {
            return effective_magnetic_field_[i];
        }
};

};

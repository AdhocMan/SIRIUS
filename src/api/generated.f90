! Warning! This file is automatically generated from sirius_api.cpp using generate_api.py script!

!> @file generated.f90
!! @brief Autogenerated interface to Fortran.
!
!> @brief Initialize the SIRIUS library.
!> @param [in] call_mpi_init If .true. then MPI_Init must be called prior to initialization.
subroutine sirius_initialize(call_mpi_init)
implicit none
!
logical, intent(in) :: call_mpi_init
!
logical(C_BOOL), target :: call_mpi_init_c_type
!
interface
subroutine sirius_initialize_aux(call_mpi_init)&
&bind(C, name="sirius_initialize")
use, intrinsic :: ISO_C_BINDING
logical(C_BOOL), intent(in) :: call_mpi_init
end subroutine
end interface

call_mpi_init_c_type = bool(call_mpi_init)
call sirius_initialize_aux(call_mpi_init_c_type)
end subroutine sirius_initialize

!
!> @brief Shut down the SIRIUS library
!> @param [in] call_mpi_fin If .true. then MPI_Finalize must be called after the shutdown.
!> @param [in] call_device_reset If .true. then cuda device is reset after shutdown.
!> @param [in] call_fftw_fin If .true. then fft_cleanup must be called after the shutdown.
subroutine sirius_finalize(call_mpi_fin,call_device_reset,call_fftw_fin)
implicit none
!
logical, optional, target, intent(in) :: call_mpi_fin
logical, optional, target, intent(in) :: call_device_reset
logical, optional, target, intent(in) :: call_fftw_fin
!
logical(C_BOOL), target :: call_mpi_fin_c_type
type(C_PTR) :: call_mpi_fin_ptr
logical(C_BOOL), target :: call_device_reset_c_type
type(C_PTR) :: call_device_reset_ptr
logical(C_BOOL), target :: call_fftw_fin_c_type
type(C_PTR) :: call_fftw_fin_ptr
!
interface
subroutine sirius_finalize_aux(call_mpi_fin,call_device_reset,call_fftw_fin)&
&bind(C, name="sirius_finalize")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: call_mpi_fin
type(C_PTR), value :: call_device_reset
type(C_PTR), value :: call_fftw_fin
end subroutine
end interface

call_mpi_fin_ptr = C_NULL_PTR
if (present(call_mpi_fin)) then
  call_mpi_fin_c_type = bool(call_mpi_fin)
  call_mpi_fin_ptr = C_LOC(call_mpi_fin_c_type)
endif
call_device_reset_ptr = C_NULL_PTR
if (present(call_device_reset)) then
  call_device_reset_c_type = bool(call_device_reset)
  call_device_reset_ptr = C_LOC(call_device_reset_c_type)
endif
call_fftw_fin_ptr = C_NULL_PTR
if (present(call_fftw_fin)) then
  call_fftw_fin_c_type = bool(call_fftw_fin)
  call_fftw_fin_ptr = C_LOC(call_fftw_fin_c_type)
endif
call sirius_finalize_aux(call_mpi_fin_ptr,call_device_reset_ptr,call_fftw_fin_ptr)
end subroutine sirius_finalize

!
!> @brief Start the timer.
!> @param [in] name Timer label.
subroutine sirius_start_timer(name)
implicit none
!
character(*), intent(in) :: name
!
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_start_timer_aux(name)&
&bind(C, name="sirius_start_timer")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: name
end subroutine
end interface

name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_start_timer_aux(name_ptr)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_start_timer

!
!> @brief Stop the running timer.
!> @param [in] name Timer label.
subroutine sirius_stop_timer(name)
implicit none
!
character(*), intent(in) :: name
!
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_stop_timer_aux(name)&
&bind(C, name="sirius_stop_timer")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: name
end subroutine
end interface

name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_stop_timer_aux(name_ptr)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_stop_timer

!
!> @brief Print all timers.
subroutine sirius_print_timers()
implicit none
!
!
!
interface
subroutine sirius_print_timers_aux()&
&bind(C, name="sirius_print_timers")
use, intrinsic :: ISO_C_BINDING
end subroutine
end interface

call sirius_print_timers_aux()
end subroutine sirius_print_timers

!
!> @brief Save all timers to JSON file.
!> @param [in] fname Name of the output JSON file.
subroutine sirius_serialize_timers(fname)
implicit none
!
character(*), intent(in) :: fname
!
character(C_CHAR), target, allocatable :: fname_c_type(:)
type(C_PTR) :: fname_ptr
!
interface
subroutine sirius_serialize_timers_aux(fname)&
&bind(C, name="sirius_serialize_timers")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: fname
end subroutine
end interface

fname_ptr = C_NULL_PTR
allocate(fname_c_type(len(fname)+1))
fname_c_type = string(fname)
fname_ptr = C_LOC(fname_c_type)
call sirius_serialize_timers_aux(fname_ptr)
if (allocated(fname_c_type)) deallocate(fname_c_type)
end subroutine sirius_serialize_timers

!
!> @brief Spline integration of f(x)*x^m.
!> @param [in] m Defines the x^{m} factor.
!> @param [in] np Number of x-points.
!> @param [in] x List of x-points.
!> @param [in] f List of function values.
!> @param [out] result Resulting value.
subroutine sirius_integrate(m,np,x,f,result)
implicit none
!
integer, intent(in) :: m
integer, intent(in) :: np
real(8), intent(in) :: x
real(8), intent(in) :: f
real(8), intent(out) :: result
!
!
interface
subroutine sirius_integrate_aux(m,np,x,f,result)&
&bind(C, name="sirius_integrate")
use, intrinsic :: ISO_C_BINDING
integer(C_INT), intent(in) :: m
integer(C_INT), intent(in) :: np
real(C_DOUBLE), intent(in) :: x
real(C_DOUBLE), intent(in) :: f
real(C_DOUBLE), intent(out) :: result
end subroutine
end interface

call sirius_integrate_aux(m,np,x,f,result)
end subroutine sirius_integrate

!
!> @brief Check if the simulation context is initialized.
!> @param [in] handler Simulation context handler.
!> @param [out] status Status of the library (true if initialized)
!> @param [out] error_code Error code.
subroutine sirius_context_initialized(handler,status,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
logical, intent(out) :: status
integer, optional, target, intent(out) :: error_code
!
logical(C_BOOL), target :: status_c_type
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_context_initialized_aux(handler,status,error_code)&
&bind(C, name="sirius_context_initialized")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
logical(C_BOOL), intent(out) :: status
type(C_PTR), value :: error_code
end subroutine
end interface

status_c_type = bool(status)
error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_context_initialized_aux(handler,status_c_type,error_code_ptr)
end subroutine sirius_context_initialized

!
!> @brief Create context of the simulation.
!> @details
!> Simulation context is the complex data structure that holds all the parameters of the individual simulation.
!> The context must be created, populated with the correct parameters and initialized before using all subsequent
!> SIRIUS functions.
!> @param [in] fcomm Entire communicator of the simulation.
!> @param [out] handler New empty simulation context.
!> @param [out] error_code Error code.
subroutine sirius_create_context(fcomm,handler,error_code)
implicit none
!
integer, intent(in) :: fcomm
type(C_PTR), intent(out) :: handler
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_create_context_aux(fcomm,handler,error_code)&
&bind(C, name="sirius_create_context")
use, intrinsic :: ISO_C_BINDING
integer(C_INT), intent(in) :: fcomm
type(C_PTR), intent(out) :: handler
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_create_context_aux(fcomm,handler,error_code_ptr)
end subroutine sirius_create_context

!
!> @brief Import parameters of simulation from a JSON string
!> @param [in] handler Simulation context handler.
!> @param [in] str JSON string with parameters or a JSON file.
subroutine sirius_import_parameters(handler,str)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), optional, target, intent(in) :: str
!
character(C_CHAR), target, allocatable :: str_c_type(:)
type(C_PTR) :: str_ptr
!
interface
subroutine sirius_import_parameters_aux(handler,str)&
&bind(C, name="sirius_import_parameters")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: str
end subroutine
end interface

str_ptr = C_NULL_PTR
if (present(str)) then
allocate(str_c_type(len(str)+1))
str_c_type = string(str)
str_ptr = C_LOC(str_c_type)
endif
call sirius_import_parameters_aux(handler,str_ptr)
if (allocated(str_c_type)) deallocate(str_c_type)
end subroutine sirius_import_parameters

!
!> @brief Set parameters of the simulation.
!> @param [in] handler Simulation context handler
!> @param [in] lmax_apw Maximum orbital quantum number for APW functions.
!> @param [in] lmax_rho Maximum orbital quantum number for density.
!> @param [in] lmax_pot Maximum orbital quantum number for potential.
!> @param [in] num_fv_states Number of first-variational states.
!> @param [in] num_bands Number of bands.
!> @param [in] num_mag_dims Number of magnetic dimensions.
!> @param [in] pw_cutoff Cutoff for G-vectors.
!> @param [in] gk_cutoff Cutoff for G+k-vectors.
!> @param [in] fft_grid_size Size of the fine-grain FFT grid.
!> @param [in] auto_rmt Set the automatic search of muffin-tin radii.
!> @param [in] gamma_point True if this is a Gamma-point calculation.
!> @param [in] use_symmetry True if crystal symmetry is taken into account.
!> @param [in] so_correction True if spin-orbit correnctio is enabled.
!> @param [in] valence_rel Valence relativity treatment.
!> @param [in] core_rel Core relativity treatment.
!> @param [in] esm_bc Type of boundary condition for effective screened medium.
!> @param [in] iter_solver_tol Tolerance of the iterative solver.
!> @param [in] iter_solver_tol_empty Tolerance for the empty states.
!> @param [in] iter_solver_type Type of iterative solver.
!> @param [in] verbosity Verbosity level.
!> @param [in] hubbard_correction True if LDA+U correction is enabled.
!> @param [in] hubbard_correction_kind Type of LDA+U implementation (simplified or full).
!> @param [in] hubbard_orbitals Type of localized orbitals.
!> @param [in] sht_coverage Type of spherical coverage (0 for Lebedev-Laikov, 1 for uniform).
!> @param [in] min_occupancy Minimum band occupancy to trat is as "occupied".
subroutine sirius_set_parameters(handler,lmax_apw,lmax_rho,lmax_pot,num_fv_states,&
&num_bands,num_mag_dims,pw_cutoff,gk_cutoff,fft_grid_size,auto_rmt,gamma_point,use_symmetry,&
&so_correction,valence_rel,core_rel,esm_bc,iter_solver_tol,iter_solver_tol_empty,&
&iter_solver_type,verbosity,hubbard_correction,hubbard_correction_kind,hubbard_orbitals,&
&sht_coverage,min_occupancy)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, optional, target, intent(in) :: lmax_apw
integer, optional, target, intent(in) :: lmax_rho
integer, optional, target, intent(in) :: lmax_pot
integer, optional, target, intent(in) :: num_fv_states
integer, optional, target, intent(in) :: num_bands
integer, optional, target, intent(in) :: num_mag_dims
real(8), optional, target, intent(in) :: pw_cutoff
real(8), optional, target, intent(in) :: gk_cutoff
integer, optional, target, intent(in) :: fft_grid_size
integer, optional, target, intent(in) :: auto_rmt
logical, optional, target, intent(in) :: gamma_point
logical, optional, target, intent(in) :: use_symmetry
logical, optional, target, intent(in) :: so_correction
character(*), optional, target, intent(in) :: valence_rel
character(*), optional, target, intent(in) :: core_rel
character(*), optional, target, intent(in) :: esm_bc
real(8), optional, target, intent(in) :: iter_solver_tol
real(8), optional, target, intent(in) :: iter_solver_tol_empty
character(*), optional, target, intent(in) :: iter_solver_type
integer, optional, target, intent(in) :: verbosity
logical, optional, target, intent(in) :: hubbard_correction
integer, optional, target, intent(in) :: hubbard_correction_kind
character(*), optional, target, intent(in) :: hubbard_orbitals
integer, optional, target, intent(in) :: sht_coverage
real(8), optional, target, intent(in) :: min_occupancy
!
type(C_PTR) :: lmax_apw_ptr
type(C_PTR) :: lmax_rho_ptr
type(C_PTR) :: lmax_pot_ptr
type(C_PTR) :: num_fv_states_ptr
type(C_PTR) :: num_bands_ptr
type(C_PTR) :: num_mag_dims_ptr
type(C_PTR) :: pw_cutoff_ptr
type(C_PTR) :: gk_cutoff_ptr
type(C_PTR) :: fft_grid_size_ptr
type(C_PTR) :: auto_rmt_ptr
logical(C_BOOL), target :: gamma_point_c_type
type(C_PTR) :: gamma_point_ptr
logical(C_BOOL), target :: use_symmetry_c_type
type(C_PTR) :: use_symmetry_ptr
logical(C_BOOL), target :: so_correction_c_type
type(C_PTR) :: so_correction_ptr
character(C_CHAR), target, allocatable :: valence_rel_c_type(:)
type(C_PTR) :: valence_rel_ptr
character(C_CHAR), target, allocatable :: core_rel_c_type(:)
type(C_PTR) :: core_rel_ptr
character(C_CHAR), target, allocatable :: esm_bc_c_type(:)
type(C_PTR) :: esm_bc_ptr
type(C_PTR) :: iter_solver_tol_ptr
type(C_PTR) :: iter_solver_tol_empty_ptr
character(C_CHAR), target, allocatable :: iter_solver_type_c_type(:)
type(C_PTR) :: iter_solver_type_ptr
type(C_PTR) :: verbosity_ptr
logical(C_BOOL), target :: hubbard_correction_c_type
type(C_PTR) :: hubbard_correction_ptr
type(C_PTR) :: hubbard_correction_kind_ptr
character(C_CHAR), target, allocatable :: hubbard_orbitals_c_type(:)
type(C_PTR) :: hubbard_orbitals_ptr
type(C_PTR) :: sht_coverage_ptr
type(C_PTR) :: min_occupancy_ptr
!
interface
subroutine sirius_set_parameters_aux(handler,lmax_apw,lmax_rho,lmax_pot,num_fv_states,&
&num_bands,num_mag_dims,pw_cutoff,gk_cutoff,fft_grid_size,auto_rmt,gamma_point,use_symmetry,&
&so_correction,valence_rel,core_rel,esm_bc,iter_solver_tol,iter_solver_tol_empty,&
&iter_solver_type,verbosity,hubbard_correction,hubbard_correction_kind,hubbard_orbitals,&
&sht_coverage,min_occupancy)&
&bind(C, name="sirius_set_parameters")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: lmax_apw
type(C_PTR), value :: lmax_rho
type(C_PTR), value :: lmax_pot
type(C_PTR), value :: num_fv_states
type(C_PTR), value :: num_bands
type(C_PTR), value :: num_mag_dims
type(C_PTR), value :: pw_cutoff
type(C_PTR), value :: gk_cutoff
type(C_PTR), value :: fft_grid_size
type(C_PTR), value :: auto_rmt
type(C_PTR), value :: gamma_point
type(C_PTR), value :: use_symmetry
type(C_PTR), value :: so_correction
type(C_PTR), value :: valence_rel
type(C_PTR), value :: core_rel
type(C_PTR), value :: esm_bc
type(C_PTR), value :: iter_solver_tol
type(C_PTR), value :: iter_solver_tol_empty
type(C_PTR), value :: iter_solver_type
type(C_PTR), value :: verbosity
type(C_PTR), value :: hubbard_correction
type(C_PTR), value :: hubbard_correction_kind
type(C_PTR), value :: hubbard_orbitals
type(C_PTR), value :: sht_coverage
type(C_PTR), value :: min_occupancy
end subroutine
end interface

lmax_apw_ptr = C_NULL_PTR
if (present(lmax_apw)) lmax_apw_ptr = C_LOC(lmax_apw)

lmax_rho_ptr = C_NULL_PTR
if (present(lmax_rho)) lmax_rho_ptr = C_LOC(lmax_rho)

lmax_pot_ptr = C_NULL_PTR
if (present(lmax_pot)) lmax_pot_ptr = C_LOC(lmax_pot)

num_fv_states_ptr = C_NULL_PTR
if (present(num_fv_states)) num_fv_states_ptr = C_LOC(num_fv_states)

num_bands_ptr = C_NULL_PTR
if (present(num_bands)) num_bands_ptr = C_LOC(num_bands)

num_mag_dims_ptr = C_NULL_PTR
if (present(num_mag_dims)) num_mag_dims_ptr = C_LOC(num_mag_dims)

pw_cutoff_ptr = C_NULL_PTR
if (present(pw_cutoff)) pw_cutoff_ptr = C_LOC(pw_cutoff)

gk_cutoff_ptr = C_NULL_PTR
if (present(gk_cutoff)) gk_cutoff_ptr = C_LOC(gk_cutoff)

fft_grid_size_ptr = C_NULL_PTR
if (present(fft_grid_size)) fft_grid_size_ptr = C_LOC(fft_grid_size)

auto_rmt_ptr = C_NULL_PTR
if (present(auto_rmt)) auto_rmt_ptr = C_LOC(auto_rmt)

gamma_point_ptr = C_NULL_PTR
if (present(gamma_point)) then
  gamma_point_c_type = bool(gamma_point)
  gamma_point_ptr = C_LOC(gamma_point_c_type)
endif
use_symmetry_ptr = C_NULL_PTR
if (present(use_symmetry)) then
  use_symmetry_c_type = bool(use_symmetry)
  use_symmetry_ptr = C_LOC(use_symmetry_c_type)
endif
so_correction_ptr = C_NULL_PTR
if (present(so_correction)) then
  so_correction_c_type = bool(so_correction)
  so_correction_ptr = C_LOC(so_correction_c_type)
endif
valence_rel_ptr = C_NULL_PTR
if (present(valence_rel)) then
allocate(valence_rel_c_type(len(valence_rel)+1))
valence_rel_c_type = string(valence_rel)
valence_rel_ptr = C_LOC(valence_rel_c_type)
endif
core_rel_ptr = C_NULL_PTR
if (present(core_rel)) then
allocate(core_rel_c_type(len(core_rel)+1))
core_rel_c_type = string(core_rel)
core_rel_ptr = C_LOC(core_rel_c_type)
endif
esm_bc_ptr = C_NULL_PTR
if (present(esm_bc)) then
allocate(esm_bc_c_type(len(esm_bc)+1))
esm_bc_c_type = string(esm_bc)
esm_bc_ptr = C_LOC(esm_bc_c_type)
endif
iter_solver_tol_ptr = C_NULL_PTR
if (present(iter_solver_tol)) iter_solver_tol_ptr = C_LOC(iter_solver_tol)

iter_solver_tol_empty_ptr = C_NULL_PTR
if (present(iter_solver_tol_empty)) iter_solver_tol_empty_ptr = C_LOC(iter_solver_tol_empty)

iter_solver_type_ptr = C_NULL_PTR
if (present(iter_solver_type)) then
allocate(iter_solver_type_c_type(len(iter_solver_type)+1))
iter_solver_type_c_type = string(iter_solver_type)
iter_solver_type_ptr = C_LOC(iter_solver_type_c_type)
endif
verbosity_ptr = C_NULL_PTR
if (present(verbosity)) verbosity_ptr = C_LOC(verbosity)

hubbard_correction_ptr = C_NULL_PTR
if (present(hubbard_correction)) then
  hubbard_correction_c_type = bool(hubbard_correction)
  hubbard_correction_ptr = C_LOC(hubbard_correction_c_type)
endif
hubbard_correction_kind_ptr = C_NULL_PTR
if (present(hubbard_correction_kind)) hubbard_correction_kind_ptr = C_LOC(hubbard_correction_kind)

hubbard_orbitals_ptr = C_NULL_PTR
if (present(hubbard_orbitals)) then
allocate(hubbard_orbitals_c_type(len(hubbard_orbitals)+1))
hubbard_orbitals_c_type = string(hubbard_orbitals)
hubbard_orbitals_ptr = C_LOC(hubbard_orbitals_c_type)
endif
sht_coverage_ptr = C_NULL_PTR
if (present(sht_coverage)) sht_coverage_ptr = C_LOC(sht_coverage)

min_occupancy_ptr = C_NULL_PTR
if (present(min_occupancy)) min_occupancy_ptr = C_LOC(min_occupancy)

call sirius_set_parameters_aux(handler,lmax_apw_ptr,lmax_rho_ptr,lmax_pot_ptr,num_fv_states_ptr,&
&num_bands_ptr,num_mag_dims_ptr,pw_cutoff_ptr,gk_cutoff_ptr,fft_grid_size_ptr,auto_rmt_ptr,&
&gamma_point_ptr,use_symmetry_ptr,so_correction_ptr,valence_rel_ptr,core_rel_ptr,&
&esm_bc_ptr,iter_solver_tol_ptr,iter_solver_tol_empty_ptr,iter_solver_type_ptr,verbosity_ptr,&
&hubbard_correction_ptr,hubbard_correction_kind_ptr,hubbard_orbitals_ptr,sht_coverage_ptr,&
&min_occupancy_ptr)
if (allocated(valence_rel_c_type)) deallocate(valence_rel_c_type)
if (allocated(core_rel_c_type)) deallocate(core_rel_c_type)
if (allocated(esm_bc_c_type)) deallocate(esm_bc_c_type)
if (allocated(iter_solver_type_c_type)) deallocate(iter_solver_type_c_type)
if (allocated(hubbard_orbitals_c_type)) deallocate(hubbard_orbitals_c_type)
end subroutine sirius_set_parameters

!
!> @brief Get parameters of the simulation.
!> @param [in] handler Simulation context handler
!> @param [out] lmax_apw Maximum orbital quantum number for APW functions.
!> @param [out] lmax_rho Maximum orbital quantum number for density.
!> @param [out] lmax_pot Maximum orbital quantum number for potential.
!> @param [out] num_fv_states Number of first-variational states.
!> @param [out] num_bands Number of bands.
!> @param [out] num_mag_dims Number of magnetic dimensions.
!> @param [out] pw_cutoff Cutoff for G-vectors.
!> @param [out] gk_cutoff Cutoff for G+k-vectors.
!> @param [out] fft_grid_size Size of the fine-grain FFT grid.
!> @param [out] auto_rmt Set the automatic search of muffin-tin radii.
!> @param [out] gamma_point True if this is a Gamma-point calculation.
!> @param [out] use_symmetry True if crystal symmetry is taken into account.
!> @param [out] so_correction True if spin-orbit correnctio is enabled.
!> @param [out] iter_solver_tol Tolerance of the iterative solver.
!> @param [out] iter_solver_tol_empty Tolerance for the empty states.
!> @param [out] verbosity Verbosity level.
!> @param [out] hubbard_correction True if LDA+U correction is enabled.
!> @param [out] evp_work_count Internal counter of total eigen-value problem work.
!> @param [out] num_loc_op_applied Internal counter of the number of wave-functions to which Hamiltonian was applied.
!> @param [out] error_code Error code.
subroutine sirius_get_parameters(handler,lmax_apw,lmax_rho,lmax_pot,num_fv_states,&
&num_bands,num_mag_dims,pw_cutoff,gk_cutoff,fft_grid_size,auto_rmt,gamma_point,use_symmetry,&
&so_correction,iter_solver_tol,iter_solver_tol_empty,verbosity,hubbard_correction,&
&evp_work_count,num_loc_op_applied,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, optional, target, intent(out) :: lmax_apw
integer, optional, target, intent(out) :: lmax_rho
integer, optional, target, intent(out) :: lmax_pot
integer, optional, target, intent(out) :: num_fv_states
integer, optional, target, intent(out) :: num_bands
integer, optional, target, intent(out) :: num_mag_dims
real(8), optional, target, intent(out) :: pw_cutoff
real(8), optional, target, intent(out) :: gk_cutoff
integer, optional, target, intent(out) :: fft_grid_size
integer, optional, target, intent(out) :: auto_rmt
logical, optional, target, intent(out) :: gamma_point
logical, optional, target, intent(out) :: use_symmetry
logical, optional, target, intent(out) :: so_correction
real(8), optional, target, intent(out) :: iter_solver_tol
real(8), optional, target, intent(out) :: iter_solver_tol_empty
integer, optional, target, intent(out) :: verbosity
logical, optional, target, intent(out) :: hubbard_correction
real(8), optional, target, intent(out) :: evp_work_count
integer, optional, target, intent(out) :: num_loc_op_applied
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: lmax_apw_ptr
type(C_PTR) :: lmax_rho_ptr
type(C_PTR) :: lmax_pot_ptr
type(C_PTR) :: num_fv_states_ptr
type(C_PTR) :: num_bands_ptr
type(C_PTR) :: num_mag_dims_ptr
type(C_PTR) :: pw_cutoff_ptr
type(C_PTR) :: gk_cutoff_ptr
type(C_PTR) :: fft_grid_size_ptr
type(C_PTR) :: auto_rmt_ptr
logical(C_BOOL), target :: gamma_point_c_type
type(C_PTR) :: gamma_point_ptr
logical(C_BOOL), target :: use_symmetry_c_type
type(C_PTR) :: use_symmetry_ptr
logical(C_BOOL), target :: so_correction_c_type
type(C_PTR) :: so_correction_ptr
type(C_PTR) :: iter_solver_tol_ptr
type(C_PTR) :: iter_solver_tol_empty_ptr
type(C_PTR) :: verbosity_ptr
logical(C_BOOL), target :: hubbard_correction_c_type
type(C_PTR) :: hubbard_correction_ptr
type(C_PTR) :: evp_work_count_ptr
type(C_PTR) :: num_loc_op_applied_ptr
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_parameters_aux(handler,lmax_apw,lmax_rho,lmax_pot,num_fv_states,&
&num_bands,num_mag_dims,pw_cutoff,gk_cutoff,fft_grid_size,auto_rmt,gamma_point,use_symmetry,&
&so_correction,iter_solver_tol,iter_solver_tol_empty,verbosity,hubbard_correction,&
&evp_work_count,num_loc_op_applied,error_code)&
&bind(C, name="sirius_get_parameters")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: lmax_apw
type(C_PTR), value :: lmax_rho
type(C_PTR), value :: lmax_pot
type(C_PTR), value :: num_fv_states
type(C_PTR), value :: num_bands
type(C_PTR), value :: num_mag_dims
type(C_PTR), value :: pw_cutoff
type(C_PTR), value :: gk_cutoff
type(C_PTR), value :: fft_grid_size
type(C_PTR), value :: auto_rmt
type(C_PTR), value :: gamma_point
type(C_PTR), value :: use_symmetry
type(C_PTR), value :: so_correction
type(C_PTR), value :: iter_solver_tol
type(C_PTR), value :: iter_solver_tol_empty
type(C_PTR), value :: verbosity
type(C_PTR), value :: hubbard_correction
type(C_PTR), value :: evp_work_count
type(C_PTR), value :: num_loc_op_applied
type(C_PTR), value :: error_code
end subroutine
end interface

lmax_apw_ptr = C_NULL_PTR
if (present(lmax_apw)) lmax_apw_ptr = C_LOC(lmax_apw)

lmax_rho_ptr = C_NULL_PTR
if (present(lmax_rho)) lmax_rho_ptr = C_LOC(lmax_rho)

lmax_pot_ptr = C_NULL_PTR
if (present(lmax_pot)) lmax_pot_ptr = C_LOC(lmax_pot)

num_fv_states_ptr = C_NULL_PTR
if (present(num_fv_states)) num_fv_states_ptr = C_LOC(num_fv_states)

num_bands_ptr = C_NULL_PTR
if (present(num_bands)) num_bands_ptr = C_LOC(num_bands)

num_mag_dims_ptr = C_NULL_PTR
if (present(num_mag_dims)) num_mag_dims_ptr = C_LOC(num_mag_dims)

pw_cutoff_ptr = C_NULL_PTR
if (present(pw_cutoff)) pw_cutoff_ptr = C_LOC(pw_cutoff)

gk_cutoff_ptr = C_NULL_PTR
if (present(gk_cutoff)) gk_cutoff_ptr = C_LOC(gk_cutoff)

fft_grid_size_ptr = C_NULL_PTR
if (present(fft_grid_size)) fft_grid_size_ptr = C_LOC(fft_grid_size)

auto_rmt_ptr = C_NULL_PTR
if (present(auto_rmt)) auto_rmt_ptr = C_LOC(auto_rmt)

gamma_point_ptr = C_NULL_PTR
if (present(gamma_point)) then
  gamma_point_c_type = bool(gamma_point)
  gamma_point_ptr = C_LOC(gamma_point_c_type)
endif
use_symmetry_ptr = C_NULL_PTR
if (present(use_symmetry)) then
  use_symmetry_c_type = bool(use_symmetry)
  use_symmetry_ptr = C_LOC(use_symmetry_c_type)
endif
so_correction_ptr = C_NULL_PTR
if (present(so_correction)) then
  so_correction_c_type = bool(so_correction)
  so_correction_ptr = C_LOC(so_correction_c_type)
endif
iter_solver_tol_ptr = C_NULL_PTR
if (present(iter_solver_tol)) iter_solver_tol_ptr = C_LOC(iter_solver_tol)

iter_solver_tol_empty_ptr = C_NULL_PTR
if (present(iter_solver_tol_empty)) iter_solver_tol_empty_ptr = C_LOC(iter_solver_tol_empty)

verbosity_ptr = C_NULL_PTR
if (present(verbosity)) verbosity_ptr = C_LOC(verbosity)

hubbard_correction_ptr = C_NULL_PTR
if (present(hubbard_correction)) then
  hubbard_correction_c_type = bool(hubbard_correction)
  hubbard_correction_ptr = C_LOC(hubbard_correction_c_type)
endif
evp_work_count_ptr = C_NULL_PTR
if (present(evp_work_count)) evp_work_count_ptr = C_LOC(evp_work_count)

num_loc_op_applied_ptr = C_NULL_PTR
if (present(num_loc_op_applied)) num_loc_op_applied_ptr = C_LOC(num_loc_op_applied)

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_parameters_aux(handler,lmax_apw_ptr,lmax_rho_ptr,lmax_pot_ptr,num_fv_states_ptr,&
&num_bands_ptr,num_mag_dims_ptr,pw_cutoff_ptr,gk_cutoff_ptr,fft_grid_size_ptr,auto_rmt_ptr,&
&gamma_point_ptr,use_symmetry_ptr,so_correction_ptr,iter_solver_tol_ptr,iter_solver_tol_empty_ptr,&
&verbosity_ptr,hubbard_correction_ptr,evp_work_count_ptr,num_loc_op_applied_ptr,error_code_ptr)
end subroutine sirius_get_parameters

!
!> @brief Add one of the XC functionals.
!> @param [in] handler Simulation context handler
!> @param [in] name LibXC label of the functional.
subroutine sirius_add_xc_functional(handler,name)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: name
!
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_add_xc_functional_aux(handler,name)&
&bind(C, name="sirius_add_xc_functional")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: name
end subroutine
end interface

name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_add_xc_functional_aux(handler,name_ptr)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_add_xc_functional

!
!> @brief Add one of the XC functionals.
!> @param [in] gs_handler Handler of the ground state
!> @param [in] name LibXC label of the functional.
subroutine sirius_insert_xc_functional(gs_handler,name)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
character(*), intent(in) :: name
!
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_insert_xc_functional_aux(gs_handler,name)&
&bind(C, name="sirius_insert_xc_functional")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), value :: name
end subroutine
end interface

name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_insert_xc_functional_aux(gs_handler,name_ptr)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_insert_xc_functional

!
!> @brief Set dimensions of the MPI grid.
!> @param [in] handler Simulation context handler
!> @param [in] ndims Number of dimensions.
!> @param [in] dims Size of each dimension.
subroutine sirius_set_mpi_grid_dims(handler,ndims,dims)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ndims
integer, intent(in) :: dims
!
!
interface
subroutine sirius_set_mpi_grid_dims_aux(handler,ndims,dims)&
&bind(C, name="sirius_set_mpi_grid_dims")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ndims
integer(C_INT), intent(in) :: dims
end subroutine
end interface

call sirius_set_mpi_grid_dims_aux(handler,ndims,dims)
end subroutine sirius_set_mpi_grid_dims

!
!> @brief Set vectors of the unit cell.
!> @param [in] handler Simulation context handler
!> @param [in] a1 1st vector
!> @param [in] a2 2nd vector
!> @param [in] a3 3rd vector
subroutine sirius_set_lattice_vectors(handler,a1,a2,a3)
implicit none
!
type(C_PTR), intent(in) :: handler
real(8), intent(in) :: a1
real(8), intent(in) :: a2
real(8), intent(in) :: a3
!
!
interface
subroutine sirius_set_lattice_vectors_aux(handler,a1,a2,a3)&
&bind(C, name="sirius_set_lattice_vectors")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
real(C_DOUBLE), intent(in) :: a1
real(C_DOUBLE), intent(in) :: a2
real(C_DOUBLE), intent(in) :: a3
end subroutine
end interface

call sirius_set_lattice_vectors_aux(handler,a1,a2,a3)
end subroutine sirius_set_lattice_vectors

!
!> @brief Initialize simulation context.
!> @param [in] handler Simulation context handler.
subroutine sirius_initialize_context(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_initialize_context_aux(handler)&
&bind(C, name="sirius_initialize_context")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_initialize_context_aux(handler)
end subroutine sirius_initialize_context

!
!> @brief Update simulation context after changing lattice or atomic positions.
!> @param [in] handler Simulation context handler.
subroutine sirius_update_context(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_update_context_aux(handler)&
&bind(C, name="sirius_update_context")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_update_context_aux(handler)
end subroutine sirius_update_context

!
!> @brief Print basic info
!> @param [in] handler Simulation context handler.
subroutine sirius_print_info(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_print_info_aux(handler)&
&bind(C, name="sirius_print_info")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_print_info_aux(handler)
end subroutine sirius_print_info

!
!> @brief Free any handler of object created by SIRIUS.
!> @param [inout] handler Handler of the object.
!> @param [out] error_code Error code
subroutine sirius_free_handler(handler,error_code)
implicit none
!
type(C_PTR), intent(inout) :: handler
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_free_handler_aux(handler,error_code)&
&bind(C, name="sirius_free_handler")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(inout) :: handler
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_free_handler_aux(handler,error_code_ptr)
end subroutine sirius_free_handler

!
!> @brief Set pointer to density or megnetization.
!> @param [in] handler Handler of the DFT ground state object.
!> @param [in] label Label of the function.
!> @param [in] f_mt Pointer to the muffin-tin part of the function.
!> @param [in] f_rg Pointer to the regualr-grid part of the function.
subroutine sirius_set_periodic_function_ptr(handler,label,f_mt,f_rg)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), optional, target, intent(in) :: f_mt
real(8), optional, target, intent(in) :: f_rg
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: f_mt_ptr
type(C_PTR) :: f_rg_ptr
!
interface
subroutine sirius_set_periodic_function_ptr_aux(handler,label,f_mt,f_rg)&
&bind(C, name="sirius_set_periodic_function_ptr")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
type(C_PTR), value :: f_mt
type(C_PTR), value :: f_rg
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
f_mt_ptr = C_NULL_PTR
if (present(f_mt)) f_mt_ptr = C_LOC(f_mt)

f_rg_ptr = C_NULL_PTR
if (present(f_rg)) f_rg_ptr = C_LOC(f_rg)

call sirius_set_periodic_function_ptr_aux(handler,label_ptr,f_mt_ptr,f_rg_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_periodic_function_ptr

!
!> @brief Create k-point set from the list of k-points.
!> @param [in] handler Simulation context handler.
!> @param [in] num_kpoints Total number of k-points in the set.
!> @param [in] kpoints List of k-points in lattice coordinates.
!> @param [in] kpoint_weights Weights of k-points.
!> @param [in] init_kset If .true. k-set will be initialized.
function sirius_create_kset(handler,num_kpoints,kpoints,kpoint_weights,init_kset) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: num_kpoints
real(8), intent(in) :: kpoints
real(8), intent(in) :: kpoint_weights
logical, intent(in) :: init_kset
type(C_PTR) :: res
!
logical(C_BOOL), target :: init_kset_c_type
!
interface
function sirius_create_kset_aux(handler,num_kpoints,kpoints,kpoint_weights,init_kset) result(res)&
&bind(C, name="sirius_create_kset")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: num_kpoints
real(C_DOUBLE), intent(in) :: kpoints
real(C_DOUBLE), intent(in) :: kpoint_weights
logical(C_BOOL), intent(in) :: init_kset
type(C_PTR) :: res
end function
end interface

init_kset_c_type = bool(init_kset)
res = sirius_create_kset_aux(handler,num_kpoints,kpoints,kpoint_weights,init_kset_c_type)
end function sirius_create_kset

!
!> @brief Create k-point set from a grid.
!> @param [in] handler Simulation context handler.
!> @param [in] k_grid dimensions of the k points grid.
!> @param [in] k_shift k point shifts.
!> @param [in] use_symmetry If .true. k-set will be generated using symmetries.
function sirius_create_kset_from_grid(handler,k_grid,k_shift,use_symmetry) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: k_grid
integer, intent(in) :: k_shift
logical, intent(in) :: use_symmetry
type(C_PTR) :: res
!
logical(C_BOOL), target :: use_symmetry_c_type
!
interface
function sirius_create_kset_from_grid_aux(handler,k_grid,k_shift,use_symmetry) result(res)&
&bind(C, name="sirius_create_kset_from_grid")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: k_grid
integer(C_INT), intent(in) :: k_shift
logical(C_BOOL), intent(in) :: use_symmetry
type(C_PTR) :: res
end function
end interface

use_symmetry_c_type = bool(use_symmetry)
res = sirius_create_kset_from_grid_aux(handler,k_grid,k_shift,use_symmetry_c_type)
end function sirius_create_kset_from_grid

!
!> @brief Create a ground state object.
!> @param [in] ks_handler Handler of the k-point set.
function sirius_create_ground_state(ks_handler) result(res)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
type(C_PTR) :: res
!
!
interface
function sirius_create_ground_state_aux(ks_handler) result(res)&
&bind(C, name="sirius_create_ground_state")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
type(C_PTR) :: res
end function
end interface

res = sirius_create_ground_state_aux(ks_handler)
end function sirius_create_ground_state

!
!> @brief Initialize k-point set.
!> @param [in] ks_handler K-point set handler.
!> @param [out] error_code Error code.
subroutine sirius_initialize_kset(ks_handler,error_code)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_initialize_kset_aux(ks_handler,error_code)&
&bind(C, name="sirius_initialize_kset")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_initialize_kset_aux(ks_handler,error_code_ptr)
end subroutine sirius_initialize_kset

!
!> @brief Find the ground state.
!> @param [in] gs_handler Handler of the ground state.
!> @param [in] density_tol Tolerance on RMS in density.
!> @param [in] energy_tol Tolerance in total energy difference.
!> @param [in] niter Maximum number of SCF iterations.
!> @param [in] save_state boolean variable indicating if we want to save the ground state.
subroutine sirius_find_ground_state(gs_handler,density_tol,energy_tol,niter,save_state)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
real(8), optional, target, intent(in) :: density_tol
real(8), optional, target, intent(in) :: energy_tol
integer, optional, target, intent(in) :: niter
logical, optional, target, intent(in) :: save_state
!
type(C_PTR) :: density_tol_ptr
type(C_PTR) :: energy_tol_ptr
type(C_PTR) :: niter_ptr
logical(C_BOOL), target :: save_state_c_type
type(C_PTR) :: save_state_ptr
!
interface
subroutine sirius_find_ground_state_aux(gs_handler,density_tol,energy_tol,niter,&
&save_state)&
&bind(C, name="sirius_find_ground_state")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), value :: density_tol
type(C_PTR), value :: energy_tol
type(C_PTR), value :: niter
type(C_PTR), value :: save_state
end subroutine
end interface

density_tol_ptr = C_NULL_PTR
if (present(density_tol)) density_tol_ptr = C_LOC(density_tol)

energy_tol_ptr = C_NULL_PTR
if (present(energy_tol)) energy_tol_ptr = C_LOC(energy_tol)

niter_ptr = C_NULL_PTR
if (present(niter)) niter_ptr = C_LOC(niter)

save_state_ptr = C_NULL_PTR
if (present(save_state)) then
  save_state_c_type = bool(save_state)
  save_state_ptr = C_LOC(save_state_c_type)
endif
call sirius_find_ground_state_aux(gs_handler,density_tol_ptr,energy_tol_ptr,niter_ptr,&
&save_state_ptr)
end subroutine sirius_find_ground_state

!
!> @brief Find the ground state using the robust
!> @param [in] gs_handler Handler of the ground state.
!> @param [in] ks_handler Handler of the k-point set.
!> @param [in] scf_density_tol Tolerance on RMS in density.
!> @param [in] scf_energy_tol Tolerance in total energy difference.
!> @param [in] scf_ninit__ Number of SCF iterations.
!> @param [in] temp__ Temperature.
!> @param [in] tol__ Tolerance.
!> @param [in] cg_restart__ CG restart.
!> @param [in] kappa__ Scalar preconditioner for pseudo Hamiltonian
subroutine sirius_find_ground_state_robust(gs_handler,ks_handler,scf_density_tol,&
&scf_energy_tol,scf_ninit__,temp__,tol__,cg_restart__,kappa__)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
real(8), optional, target, intent(in) :: scf_density_tol
real(8), optional, target, intent(in) :: scf_energy_tol
integer, optional, target, intent(in) :: scf_ninit__
real(8), optional, target, intent(in) :: temp__
real(8), optional, target, intent(in) :: tol__
integer, optional, target, intent(in) :: cg_restart__
real(8), optional, target, intent(in) :: kappa__
!
type(C_PTR) :: scf_density_tol_ptr
type(C_PTR) :: scf_energy_tol_ptr
type(C_PTR) :: scf_ninit___ptr
type(C_PTR) :: temp___ptr
type(C_PTR) :: tol___ptr
type(C_PTR) :: cg_restart___ptr
type(C_PTR) :: kappa___ptr
!
interface
subroutine sirius_find_ground_state_robust_aux(gs_handler,ks_handler,scf_density_tol,&
&scf_energy_tol,scf_ninit__,temp__,tol__,cg_restart__,kappa__)&
&bind(C, name="sirius_find_ground_state_robust")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
type(C_PTR), value :: scf_density_tol
type(C_PTR), value :: scf_energy_tol
type(C_PTR), value :: scf_ninit__
type(C_PTR), value :: temp__
type(C_PTR), value :: tol__
type(C_PTR), value :: cg_restart__
type(C_PTR), value :: kappa__
end subroutine
end interface

scf_density_tol_ptr = C_NULL_PTR
if (present(scf_density_tol)) scf_density_tol_ptr = C_LOC(scf_density_tol)

scf_energy_tol_ptr = C_NULL_PTR
if (present(scf_energy_tol)) scf_energy_tol_ptr = C_LOC(scf_energy_tol)

scf_ninit___ptr = C_NULL_PTR
if (present(scf_ninit__)) scf_ninit___ptr = C_LOC(scf_ninit__)

temp___ptr = C_NULL_PTR
if (present(temp__)) temp___ptr = C_LOC(temp__)

tol___ptr = C_NULL_PTR
if (present(tol__)) tol___ptr = C_LOC(tol__)

cg_restart___ptr = C_NULL_PTR
if (present(cg_restart__)) cg_restart___ptr = C_LOC(cg_restart__)

kappa___ptr = C_NULL_PTR
if (present(kappa__)) kappa___ptr = C_LOC(kappa__)

call sirius_find_ground_state_robust_aux(gs_handler,ks_handler,scf_density_tol_ptr,&
&scf_energy_tol_ptr,scf_ninit___ptr,temp___ptr,tol___ptr,cg_restart___ptr,kappa___ptr)
end subroutine sirius_find_ground_state_robust

!
!> @brief Update a ground state object after change of atomic coordinates or lattice vectors.
!> @param [in] gs_handler Ground-state handler.
subroutine sirius_update_ground_state(gs_handler)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
!
!
interface
subroutine sirius_update_ground_state_aux(gs_handler)&
&bind(C, name="sirius_update_ground_state")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
end subroutine
end interface

call sirius_update_ground_state_aux(gs_handler)
end subroutine sirius_update_ground_state

!
!> @brief Add new atom type to the unit cell.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type unique label.
!> @param [in] fname Species file name (in JSON format).
!> @param [in] zn Nucleus charge.
!> @param [in] symbol Atomic symbol.
!> @param [in] mass Atomic mass.
!> @param [in] spin_orbit True if spin-orbit correction is enabled for this atom type.
subroutine sirius_add_atom_type(handler,label,fname,zn,symbol,mass,spin_orbit)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
character(*), optional, target, intent(in) :: fname
integer, optional, target, intent(in) :: zn
character(*), optional, target, intent(in) :: symbol
real(8), optional, target, intent(in) :: mass
logical, optional, target, intent(in) :: spin_orbit
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
character(C_CHAR), target, allocatable :: fname_c_type(:)
type(C_PTR) :: fname_ptr
type(C_PTR) :: zn_ptr
character(C_CHAR), target, allocatable :: symbol_c_type(:)
type(C_PTR) :: symbol_ptr
type(C_PTR) :: mass_ptr
logical(C_BOOL), target :: spin_orbit_c_type
type(C_PTR) :: spin_orbit_ptr
!
interface
subroutine sirius_add_atom_type_aux(handler,label,fname,zn,symbol,mass,spin_orbit)&
&bind(C, name="sirius_add_atom_type")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
type(C_PTR), value :: fname
type(C_PTR), value :: zn
type(C_PTR), value :: symbol
type(C_PTR), value :: mass
type(C_PTR), value :: spin_orbit
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
fname_ptr = C_NULL_PTR
if (present(fname)) then
allocate(fname_c_type(len(fname)+1))
fname_c_type = string(fname)
fname_ptr = C_LOC(fname_c_type)
endif
zn_ptr = C_NULL_PTR
if (present(zn)) zn_ptr = C_LOC(zn)

symbol_ptr = C_NULL_PTR
if (present(symbol)) then
allocate(symbol_c_type(len(symbol)+1))
symbol_c_type = string(symbol)
symbol_ptr = C_LOC(symbol_c_type)
endif
mass_ptr = C_NULL_PTR
if (present(mass)) mass_ptr = C_LOC(mass)

spin_orbit_ptr = C_NULL_PTR
if (present(spin_orbit)) then
  spin_orbit_c_type = bool(spin_orbit)
  spin_orbit_ptr = C_LOC(spin_orbit_c_type)
endif
call sirius_add_atom_type_aux(handler,label_ptr,fname_ptr,zn_ptr,symbol_ptr,mass_ptr,&
&spin_orbit_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
if (allocated(fname_c_type)) deallocate(fname_c_type)
if (allocated(symbol_c_type)) deallocate(symbol_c_type)
end subroutine sirius_add_atom_type

!
!> @brief Set radial grid of the atom type.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] num_radial_points Number of radial grid points.
!> @param [in] radial_points List of radial grid points.
subroutine sirius_set_atom_type_radial_grid(handler,label,num_radial_points,radial_points)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: num_radial_points
real(8), intent(in) :: radial_points
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_atom_type_radial_grid_aux(handler,label,num_radial_points,&
&radial_points)&
&bind(C, name="sirius_set_atom_type_radial_grid")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: num_radial_points
real(C_DOUBLE), intent(in) :: radial_points
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_atom_type_radial_grid_aux(handler,label_ptr,num_radial_points,radial_points)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_radial_grid

!
!> @brief Set radial grid of the free atom (up to effectice infinity).
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] num_radial_points Number of radial grid points.
!> @param [in] radial_points List of radial grid points.
subroutine sirius_set_atom_type_radial_grid_inf(handler,label,num_radial_points,&
&radial_points)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: num_radial_points
real(8), intent(in) :: radial_points
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_atom_type_radial_grid_inf_aux(handler,label,num_radial_points,&
&radial_points)&
&bind(C, name="sirius_set_atom_type_radial_grid_inf")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: num_radial_points
real(C_DOUBLE), intent(in) :: radial_points
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_atom_type_radial_grid_inf_aux(handler,label_ptr,num_radial_points,&
&radial_points)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_radial_grid_inf

!
!> @brief Add one of the radial functions.
!> @param [in] handler Simulation context handler.
!> @param [in] atom_type Label of the atom type.
!> @param [in] label Label of the radial function.
!> @param [in] rf Array with radial function values.
!> @param [in] num_points Length of radial function array.
!> @param [in] n Orbital quantum number.
!> @param [in] l angular momentum.
!> @param [in] idxrf1 First index of radial function (for Q-operator).
!> @param [in] idxrf2 Second index of radial function (for Q-operator).
!> @param [in] occ Occupancy of the wave-function.
subroutine sirius_add_atom_type_radial_function(handler,atom_type,label,rf,num_points,&
&n,l,idxrf1,idxrf2,occ)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: atom_type
character(*), intent(in) :: label
real(8), intent(in) :: rf
integer, intent(in) :: num_points
integer, optional, target, intent(in) :: n
integer, optional, target, intent(in) :: l
integer, optional, target, intent(in) :: idxrf1
integer, optional, target, intent(in) :: idxrf2
real(8), optional, target, intent(in) :: occ
!
character(C_CHAR), target, allocatable :: atom_type_c_type(:)
type(C_PTR) :: atom_type_ptr
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: n_ptr
type(C_PTR) :: l_ptr
type(C_PTR) :: idxrf1_ptr
type(C_PTR) :: idxrf2_ptr
type(C_PTR) :: occ_ptr
!
interface
subroutine sirius_add_atom_type_radial_function_aux(handler,atom_type,label,rf,num_points,&
&n,l,idxrf1,idxrf2,occ)&
&bind(C, name="sirius_add_atom_type_radial_function")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: atom_type
type(C_PTR), value :: label
real(C_DOUBLE), intent(in) :: rf
integer(C_INT), intent(in) :: num_points
type(C_PTR), value :: n
type(C_PTR), value :: l
type(C_PTR), value :: idxrf1
type(C_PTR), value :: idxrf2
type(C_PTR), value :: occ
end subroutine
end interface

atom_type_ptr = C_NULL_PTR
allocate(atom_type_c_type(len(atom_type)+1))
atom_type_c_type = string(atom_type)
atom_type_ptr = C_LOC(atom_type_c_type)
label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
n_ptr = C_NULL_PTR
if (present(n)) n_ptr = C_LOC(n)

l_ptr = C_NULL_PTR
if (present(l)) l_ptr = C_LOC(l)

idxrf1_ptr = C_NULL_PTR
if (present(idxrf1)) idxrf1_ptr = C_LOC(idxrf1)

idxrf2_ptr = C_NULL_PTR
if (present(idxrf2)) idxrf2_ptr = C_LOC(idxrf2)

occ_ptr = C_NULL_PTR
if (present(occ)) occ_ptr = C_LOC(occ)

call sirius_add_atom_type_radial_function_aux(handler,atom_type_ptr,label_ptr,rf,&
&num_points,n_ptr,l_ptr,idxrf1_ptr,idxrf2_ptr,occ_ptr)
if (allocated(atom_type_c_type)) deallocate(atom_type_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_add_atom_type_radial_function

!
!> @brief Set the hubbard correction for the atomic type.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] l Orbital quantum number.
!> @param [in] n principal quantum number (s, p, d, f)
!> @param [in] occ Atomic shell occupancy.
!> @param [in] U Hubbard U parameter.
!> @param [in] J Exchange J parameter for the full interaction treatment.
!> @param [in] alpha J_alpha for the simple interaction treatment.
!> @param [in] beta J_beta for the simple interaction treatment.
!> @param [in] J0 J0 for the simple interaction treatment.
subroutine sirius_set_atom_type_hubbard(handler,label,l,n,occ,U,J,alpha,beta,J0)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: l
integer, intent(in) :: n
real(8), intent(in) :: occ
real(8), intent(in) :: U
real(8), intent(in) :: J
real(8), intent(in) :: alpha
real(8), intent(in) :: beta
real(8), intent(in) :: J0
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_atom_type_hubbard_aux(handler,label,l,n,occ,U,J,alpha,beta,&
&J0)&
&bind(C, name="sirius_set_atom_type_hubbard")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: l
integer(C_INT), intent(in) :: n
real(C_DOUBLE), intent(in) :: occ
real(C_DOUBLE), intent(in) :: U
real(C_DOUBLE), intent(in) :: J
real(C_DOUBLE), intent(in) :: alpha
real(C_DOUBLE), intent(in) :: beta
real(C_DOUBLE), intent(in) :: J0
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_atom_type_hubbard_aux(handler,label_ptr,l,n,occ,U,J,alpha,beta,J0)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_hubbard

!
!> @brief Set ionic part of D-operator matrix.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] num_beta Number of beta-projectors.
!> @param [in] dion Ionic part of D-operator matrix.
subroutine sirius_set_atom_type_dion(handler,label,num_beta,dion)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: num_beta
real(8), intent(in) :: dion
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_atom_type_dion_aux(handler,label,num_beta,dion)&
&bind(C, name="sirius_set_atom_type_dion")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: num_beta
real(C_DOUBLE), intent(in) :: dion
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_atom_type_dion_aux(handler,label_ptr,num_beta,dion)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_dion

!
!> @brief Set PAW related data.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] core_energy Core-electrons energy contribution.
!> @param [in] occupations array of orbital occupancies
!> @param [in] num_occ size of the occupations array
subroutine sirius_set_atom_type_paw(handler,label,core_energy,occupations,num_occ)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(in) :: core_energy
real(8), intent(in) :: occupations
integer, intent(in) :: num_occ
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_atom_type_paw_aux(handler,label,core_energy,occupations,num_occ)&
&bind(C, name="sirius_set_atom_type_paw")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(in) :: core_energy
real(C_DOUBLE), intent(in) :: occupations
integer(C_INT), intent(in) :: num_occ
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_atom_type_paw_aux(handler,label_ptr,core_energy,occupations,num_occ)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_paw

!
!> @brief Add atom to the unit cell.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] position Atom position in lattice coordinates.
!> @param [in] vector_field Starting magnetization.
subroutine sirius_add_atom(handler,label,position,vector_field)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(in) :: position
real(8), optional, target, intent(in) :: vector_field
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: vector_field_ptr
!
interface
subroutine sirius_add_atom_aux(handler,label,position,vector_field)&
&bind(C, name="sirius_add_atom")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(in) :: position
type(C_PTR), value :: vector_field
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
vector_field_ptr = C_NULL_PTR
if (present(vector_field)) vector_field_ptr = C_LOC(vector_field)

call sirius_add_atom_aux(handler,label_ptr,position,vector_field_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_add_atom

!
!> @brief Set new atomic position.
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] position Atom position in lattice coordinates.
subroutine sirius_set_atom_position(handler,ia,position)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
real(8), intent(in) :: position
!
!
interface
subroutine sirius_set_atom_position_aux(handler,ia,position)&
&bind(C, name="sirius_set_atom_position")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
real(C_DOUBLE), intent(in) :: position
end subroutine
end interface

call sirius_set_atom_position_aux(handler,ia,position)
end subroutine sirius_set_atom_position

!
!> @brief Set plane-wave coefficients of a periodic function.
!> @param [in] handler Ground state handler.
!> @param [in] label Label of the function.
!> @param [in] pw_coeffs Local array of plane-wave coefficients.
!> @param [in] transform_to_rg True if function has to be transformed to real-space grid.
!> @param [in] ngv Local number of G-vectors.
!> @param [in] gvl List of G-vectors in lattice coordinates (Miller indices).
!> @param [in] comm MPI communicator used in distribution of G-vectors
subroutine sirius_set_pw_coeffs(handler,label,pw_coeffs,transform_to_rg,ngv,gvl,&
&comm)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
complex(8), intent(in) :: pw_coeffs
logical, optional, target, intent(in) :: transform_to_rg
integer, optional, target, intent(in) :: ngv
integer, optional, target, intent(in) :: gvl
integer, optional, target, intent(in) :: comm
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: transform_to_rg_c_type
type(C_PTR) :: transform_to_rg_ptr
type(C_PTR) :: ngv_ptr
type(C_PTR) :: gvl_ptr
type(C_PTR) :: comm_ptr
!
interface
subroutine sirius_set_pw_coeffs_aux(handler,label,pw_coeffs,transform_to_rg,ngv,&
&gvl,comm)&
&bind(C, name="sirius_set_pw_coeffs")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
complex(C_DOUBLE), intent(in) :: pw_coeffs
type(C_PTR), value :: transform_to_rg
type(C_PTR), value :: ngv
type(C_PTR), value :: gvl
type(C_PTR), value :: comm
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
transform_to_rg_ptr = C_NULL_PTR
if (present(transform_to_rg)) then
  transform_to_rg_c_type = bool(transform_to_rg)
  transform_to_rg_ptr = C_LOC(transform_to_rg_c_type)
endif
ngv_ptr = C_NULL_PTR
if (present(ngv)) ngv_ptr = C_LOC(ngv)

gvl_ptr = C_NULL_PTR
if (present(gvl)) gvl_ptr = C_LOC(gvl)

comm_ptr = C_NULL_PTR
if (present(comm)) comm_ptr = C_LOC(comm)

call sirius_set_pw_coeffs_aux(handler,label_ptr,pw_coeffs,transform_to_rg_ptr,ngv_ptr,&
&gvl_ptr,comm_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_pw_coeffs

!
!> @brief Get plane-wave coefficients of a periodic function.
!> @param [in] handler Ground state handler.
!> @param [in] label Label of the function.
!> @param [in] pw_coeffs Local array of plane-wave coefficients.
!> @param [in] ngv Local number of G-vectors.
!> @param [in] gvl List of G-vectors in lattice coordinates (Miller indices).
!> @param [in] comm MPI communicator used in distribution of G-vectors
subroutine sirius_get_pw_coeffs(handler,label,pw_coeffs,ngv,gvl,comm)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
complex(8), intent(in) :: pw_coeffs
integer, optional, target, intent(in) :: ngv
integer, optional, target, intent(in) :: gvl
integer, optional, target, intent(in) :: comm
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: ngv_ptr
type(C_PTR) :: gvl_ptr
type(C_PTR) :: comm_ptr
!
interface
subroutine sirius_get_pw_coeffs_aux(handler,label,pw_coeffs,ngv,gvl,comm)&
&bind(C, name="sirius_get_pw_coeffs")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
complex(C_DOUBLE), intent(in) :: pw_coeffs
type(C_PTR), value :: ngv
type(C_PTR), value :: gvl
type(C_PTR), value :: comm
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
ngv_ptr = C_NULL_PTR
if (present(ngv)) ngv_ptr = C_LOC(ngv)

gvl_ptr = C_NULL_PTR
if (present(gvl)) gvl_ptr = C_LOC(gvl)

comm_ptr = C_NULL_PTR
if (present(comm)) comm_ptr = C_LOC(comm)

call sirius_get_pw_coeffs_aux(handler,label_ptr,pw_coeffs,ngv_ptr,gvl_ptr,comm_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_pw_coeffs

!
!> @brief Get atom type contribution to plane-wave coefficients of a periodic function.
!> @param [in] handler Simulation context handler.
!> @param [in] atom_type Label of the atom type.
!> @param [in] label Label of the function.
!> @param [in] pw_coeffs Local array of plane-wave coefficients.
!> @param [in] ngv Local number of G-vectors.
!> @param [in] gvl List of G-vectors in lattice coordinates (Miller indices).
!> @param [in] comm MPI communicator used in distribution of G-vectors
subroutine sirius_get_pw_coeffs_real(handler,atom_type,label,pw_coeffs,ngv,gvl,comm)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: atom_type
character(*), intent(in) :: label
real(8), intent(in) :: pw_coeffs
integer, optional, target, intent(in) :: ngv
integer, optional, target, intent(in) :: gvl
integer, optional, target, intent(in) :: comm
!
character(C_CHAR), target, allocatable :: atom_type_c_type(:)
type(C_PTR) :: atom_type_ptr
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: ngv_ptr
type(C_PTR) :: gvl_ptr
type(C_PTR) :: comm_ptr
!
interface
subroutine sirius_get_pw_coeffs_real_aux(handler,atom_type,label,pw_coeffs,ngv,gvl,&
&comm)&
&bind(C, name="sirius_get_pw_coeffs_real")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: atom_type
type(C_PTR), value :: label
real(C_DOUBLE), intent(in) :: pw_coeffs
type(C_PTR), value :: ngv
type(C_PTR), value :: gvl
type(C_PTR), value :: comm
end subroutine
end interface

atom_type_ptr = C_NULL_PTR
allocate(atom_type_c_type(len(atom_type)+1))
atom_type_c_type = string(atom_type)
atom_type_ptr = C_LOC(atom_type_c_type)
label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
ngv_ptr = C_NULL_PTR
if (present(ngv)) ngv_ptr = C_LOC(ngv)

gvl_ptr = C_NULL_PTR
if (present(gvl)) gvl_ptr = C_LOC(gvl)

comm_ptr = C_NULL_PTR
if (present(comm)) comm_ptr = C_LOC(comm)

call sirius_get_pw_coeffs_real_aux(handler,atom_type_ptr,label_ptr,pw_coeffs,ngv_ptr,&
&gvl_ptr,comm_ptr)
if (allocated(atom_type_c_type)) deallocate(atom_type_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_pw_coeffs_real

!
!> @brief Initialize the subspace of wave-functions.
!> @param [in] gs_handler Ground state handler.
!> @param [in] ks_handler K-point set handler.
subroutine sirius_initialize_subspace(gs_handler,ks_handler)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
!
!
interface
subroutine sirius_initialize_subspace_aux(gs_handler,ks_handler)&
&bind(C, name="sirius_initialize_subspace")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
end subroutine
end interface

call sirius_initialize_subspace_aux(gs_handler,ks_handler)
end subroutine sirius_initialize_subspace

!
!> @brief Find eigen-states of the Hamiltonian/
!> @param [in] gs_handler Ground state handler.
!> @param [in] ks_handler K-point set handler.
!> @param [in] precompute True if neccessary data to setup eigen-value problem must be automatically precomputed.
!> @param [in] iter_solver_tol Iterative solver tolerance.
subroutine sirius_find_eigen_states(gs_handler,ks_handler,precompute,iter_solver_tol)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
logical, intent(in) :: precompute
real(8), optional, target, intent(in) :: iter_solver_tol
!
logical(C_BOOL), target :: precompute_c_type
type(C_PTR) :: iter_solver_tol_ptr
!
interface
subroutine sirius_find_eigen_states_aux(gs_handler,ks_handler,precompute,iter_solver_tol)&
&bind(C, name="sirius_find_eigen_states")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), intent(in) :: ks_handler
logical(C_BOOL), intent(in) :: precompute
type(C_PTR), value :: iter_solver_tol
end subroutine
end interface

precompute_c_type = bool(precompute)
iter_solver_tol_ptr = C_NULL_PTR
if (present(iter_solver_tol)) iter_solver_tol_ptr = C_LOC(iter_solver_tol)

call sirius_find_eigen_states_aux(gs_handler,ks_handler,precompute_c_type,iter_solver_tol_ptr)
end subroutine sirius_find_eigen_states

!
!> @brief Generate D-operator matrix.
!> @param [in] handler Ground state handler.
subroutine sirius_generate_d_operator_matrix(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_generate_d_operator_matrix_aux(handler)&
&bind(C, name="sirius_generate_d_operator_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_generate_d_operator_matrix_aux(handler)
end subroutine sirius_generate_d_operator_matrix

!
!> @brief Generate initial density.
!> @param [in] handler Ground state handler.
subroutine sirius_generate_initial_density(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_generate_initial_density_aux(handler)&
&bind(C, name="sirius_generate_initial_density")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_generate_initial_density_aux(handler)
end subroutine sirius_generate_initial_density

!
!> @brief Generate effective potential and magnetic field.
!> @param [in] handler Ground state handler.
subroutine sirius_generate_effective_potential(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_generate_effective_potential_aux(handler)&
&bind(C, name="sirius_generate_effective_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_generate_effective_potential_aux(handler)
end subroutine sirius_generate_effective_potential

!
!> @brief Generate charge density and magnetization.
!> @param [in] gs_handler Ground state handler.
!> @param [in] add_core Add core charge density in the muffin-tins.
!> @param [in] transform_to_rg If true, density and magnetization are transformed to real-space grid.
subroutine sirius_generate_density(gs_handler,add_core,transform_to_rg)
implicit none
!
type(C_PTR), intent(in) :: gs_handler
logical, optional, target, intent(in) :: add_core
logical, optional, target, intent(in) :: transform_to_rg
!
logical(C_BOOL), target :: add_core_c_type
type(C_PTR) :: add_core_ptr
logical(C_BOOL), target :: transform_to_rg_c_type
type(C_PTR) :: transform_to_rg_ptr
!
interface
subroutine sirius_generate_density_aux(gs_handler,add_core,transform_to_rg)&
&bind(C, name="sirius_generate_density")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: gs_handler
type(C_PTR), value :: add_core
type(C_PTR), value :: transform_to_rg
end subroutine
end interface

add_core_ptr = C_NULL_PTR
if (present(add_core)) then
  add_core_c_type = bool(add_core)
  add_core_ptr = C_LOC(add_core_c_type)
endif
transform_to_rg_ptr = C_NULL_PTR
if (present(transform_to_rg)) then
  transform_to_rg_c_type = bool(transform_to_rg)
  transform_to_rg_ptr = C_LOC(transform_to_rg_c_type)
endif
call sirius_generate_density_aux(gs_handler,add_core_ptr,transform_to_rg_ptr)
end subroutine sirius_generate_density

!
!> @brief Set band occupancies.
!> @param [in] ks_handler K-point set handler.
!> @param [in] ik Global index of k-point.
!> @param [in] ispn Spin component.
!> @param [in] band_occupancies Array of band occupancies.
subroutine sirius_set_band_occupancies(ks_handler,ik,ispn,band_occupancies)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, intent(in) :: ik
integer, intent(in) :: ispn
real(8), intent(in) :: band_occupancies
!
!
interface
subroutine sirius_set_band_occupancies_aux(ks_handler,ik,ispn,band_occupancies)&
&bind(C, name="sirius_set_band_occupancies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT), intent(in) :: ik
integer(C_INT), intent(in) :: ispn
real(C_DOUBLE), intent(in) :: band_occupancies
end subroutine
end interface

call sirius_set_band_occupancies_aux(ks_handler,ik,ispn,band_occupancies)
end subroutine sirius_set_band_occupancies

!
!> @brief Set band occupancies.
!> @param [in] ks_handler K-point set handler.
!> @param [in] ik Global index of k-point.
!> @param [in] ispn Spin component.
!> @param [out] band_occupancies Array of band occupancies.
subroutine sirius_get_band_occupancies(ks_handler,ik,ispn,band_occupancies)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, intent(in) :: ik
integer, intent(in) :: ispn
real(8), intent(out) :: band_occupancies
!
!
interface
subroutine sirius_get_band_occupancies_aux(ks_handler,ik,ispn,band_occupancies)&
&bind(C, name="sirius_get_band_occupancies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT), intent(in) :: ik
integer(C_INT), intent(in) :: ispn
real(C_DOUBLE), intent(out) :: band_occupancies
end subroutine
end interface

call sirius_get_band_occupancies_aux(ks_handler,ik,ispn,band_occupancies)
end subroutine sirius_get_band_occupancies

!
!> @brief Get band energies.
!> @param [in] ks_handler K-point set handler.
!> @param [in] ik Global index of k-point.
!> @param [in] ispn Spin component.
!> @param [out] band_energies Array of band energies.
subroutine sirius_get_band_energies(ks_handler,ik,ispn,band_energies)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, intent(in) :: ik
integer, intent(in) :: ispn
real(8), intent(out) :: band_energies
!
!
interface
subroutine sirius_get_band_energies_aux(ks_handler,ik,ispn,band_energies)&
&bind(C, name="sirius_get_band_energies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT), intent(in) :: ik
integer(C_INT), intent(in) :: ispn
real(C_DOUBLE), intent(out) :: band_energies
end subroutine
end interface

call sirius_get_band_energies_aux(ks_handler,ik,ispn,band_energies)
end subroutine sirius_get_band_energies

!
!> @brief Get D-operator matrix
!> @param [in] handler Simulation context handler.
!> @param [in] ia Global index of atom.
!> @param [in] ispn Spin component.
!> @param [out] d_mtrx D-matrix.
!> @param [in] ld Leading dimention of D-matrix.
subroutine sirius_get_d_operator_matrix(handler,ia,ispn,d_mtrx,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
integer, intent(in) :: ispn
real(8), intent(out) :: d_mtrx
integer, intent(in) :: ld
!
!
interface
subroutine sirius_get_d_operator_matrix_aux(handler,ia,ispn,d_mtrx,ld)&
&bind(C, name="sirius_get_d_operator_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
integer(C_INT), intent(in) :: ispn
real(C_DOUBLE), intent(out) :: d_mtrx
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_get_d_operator_matrix_aux(handler,ia,ispn,d_mtrx,ld)
end subroutine sirius_get_d_operator_matrix

!
!> @brief Set D-operator matrix
!> @param [in] handler Simulation context handler.
!> @param [in] ia Global index of atom.
!> @param [in] ispn Spin component.
!> @param [out] d_mtrx D-matrix.
!> @param [in] ld Leading dimention of D-matrix.
subroutine sirius_set_d_operator_matrix(handler,ia,ispn,d_mtrx,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
integer, intent(in) :: ispn
real(8), intent(out) :: d_mtrx
integer, intent(in) :: ld
!
!
interface
subroutine sirius_set_d_operator_matrix_aux(handler,ia,ispn,d_mtrx,ld)&
&bind(C, name="sirius_set_d_operator_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
integer(C_INT), intent(in) :: ispn
real(C_DOUBLE), intent(out) :: d_mtrx
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_set_d_operator_matrix_aux(handler,ia,ispn,d_mtrx,ld)
end subroutine sirius_set_d_operator_matrix

!
!> @brief Set Q-operator matrix
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [out] q_mtrx Q-matrix.
!> @param [in] ld Leading dimention of Q-matrix.
subroutine sirius_set_q_operator_matrix(handler,label,q_mtrx,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(out) :: q_mtrx
integer, intent(in) :: ld
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_set_q_operator_matrix_aux(handler,label,q_mtrx,ld)&
&bind(C, name="sirius_set_q_operator_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(out) :: q_mtrx
integer(C_INT), intent(in) :: ld
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_set_q_operator_matrix_aux(handler,label_ptr,q_mtrx,ld)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_q_operator_matrix

!
!> @brief Get Q-operator matrix
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [out] q_mtrx Q-matrix.
!> @param [in] ld Leading dimention of Q-matrix.
subroutine sirius_get_q_operator_matrix(handler,label,q_mtrx,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(out) :: q_mtrx
integer, intent(in) :: ld
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_get_q_operator_matrix_aux(handler,label,q_mtrx,ld)&
&bind(C, name="sirius_get_q_operator_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(out) :: q_mtrx
integer(C_INT), intent(in) :: ld
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_get_q_operator_matrix_aux(handler,label_ptr,q_mtrx,ld)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_q_operator_matrix

!
!> @brief Get all components of complex density matrix.
!> @param [in] handler DFT ground state handler.
!> @param [in] ia Global index of atom.
!> @param [out] dm Complex density matrix.
!> @param [in] ld Leading dimention of the density matrix.
subroutine sirius_get_density_matrix(handler,ia,dm,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
complex(8), intent(out) :: dm
integer, intent(in) :: ld
!
!
interface
subroutine sirius_get_density_matrix_aux(handler,ia,dm,ld)&
&bind(C, name="sirius_get_density_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
complex(C_DOUBLE), intent(out) :: dm
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_get_density_matrix_aux(handler,ia,dm,ld)
end subroutine sirius_get_density_matrix

!
!> @brief Set all components of complex density matrix.
!> @param [in] handler DFT ground state handler.
!> @param [in] ia Global index of atom.
!> @param [out] dm Complex density matrix.
!> @param [in] ld Leading dimention of the density matrix.
subroutine sirius_set_density_matrix(handler,ia,dm,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
complex(8), intent(out) :: dm
integer, intent(in) :: ld
!
!
interface
subroutine sirius_set_density_matrix_aux(handler,ia,dm,ld)&
&bind(C, name="sirius_set_density_matrix")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
complex(C_DOUBLE), intent(out) :: dm
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_set_density_matrix_aux(handler,ia,dm,ld)
end subroutine sirius_set_density_matrix

!
!> @brief Get one of the total energy components.
!> @param [in] handler DFT ground state handler.
!> @param [in] label Label of the energy component to get.
!> @param [out] energy Total energy component.
subroutine sirius_get_energy(handler,label,energy)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(out) :: energy
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_get_energy_aux(handler,label,energy)&
&bind(C, name="sirius_get_energy")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(out) :: energy
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_get_energy_aux(handler,label_ptr,energy)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_energy

!
!> @brief Get one of the total force components.
!> @param [in] handler DFT ground state handler.
!> @param [in] label Label of the force component to get.
!> @param [out] forces Total force component for each atom.
subroutine sirius_get_forces(handler,label,forces)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(out) :: forces
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_get_forces_aux(handler,label,forces)&
&bind(C, name="sirius_get_forces")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(out) :: forces
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_get_forces_aux(handler,label_ptr,forces)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_forces

!
!> @brief Get one of the stress tensor components.
!> @param [in] handler DFT ground state handler.
!> @param [in] label Label of the stress tensor component to get.
!> @param [out] stress_tensor Component of the total stress tensor.
subroutine sirius_get_stress_tensor(handler,label,stress_tensor)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
real(8), intent(out) :: stress_tensor
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_get_stress_tensor_aux(handler,label,stress_tensor)&
&bind(C, name="sirius_get_stress_tensor")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
real(C_DOUBLE), intent(out) :: stress_tensor
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_get_stress_tensor_aux(handler,label_ptr,stress_tensor)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_stress_tensor

!
!> @brief Get the number of beta-projectors for an atom type.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
function sirius_get_num_beta_projectors(handler,label) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer :: res
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
function sirius_get_num_beta_projectors_aux(handler,label) result(res)&
&bind(C, name="sirius_get_num_beta_projectors")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT) :: res
end function
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
res = sirius_get_num_beta_projectors_aux(handler,label_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end function sirius_get_num_beta_projectors

!
!> @brief Get plane-wave coefficients of Q-operator
!> @param [in] handler Simulation context handler.
!> @param [in] label Label of the atom type.
!> @param [in] xi1 First index of beta-projector atomic function.
!> @param [in] xi2 Second index of beta-projector atomic function.
!> @param [in] ngv Number of G-vectors.
!> @param [in] gvl G-vectors in lattice coordinats.
!> @param [out] q_pw Plane-wave coefficients of Q augmentation operator.
subroutine sirius_get_q_operator(handler,label,xi1,xi2,ngv,gvl,q_pw)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: xi1
integer, intent(in) :: xi2
integer, intent(in) :: ngv
integer, intent(in) :: gvl
complex(8), intent(out) :: q_pw
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
!
interface
subroutine sirius_get_q_operator_aux(handler,label,xi1,xi2,ngv,gvl,q_pw)&
&bind(C, name="sirius_get_q_operator")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: xi1
integer(C_INT), intent(in) :: xi2
integer(C_INT), intent(in) :: ngv
integer(C_INT), intent(in) :: gvl
complex(C_DOUBLE), intent(out) :: q_pw
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
call sirius_get_q_operator_aux(handler,label_ptr,xi1,xi2,ngv,gvl,q_pw)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_q_operator

!
!> @brief Get wave-functions.
!> @param [in] ks_handler K-point set handler.
!> @param [in] ik Global index of k-point
!> @param [in] ispn Spin index.
!> @param [in] npw Local number of G+k vectors.
!> @param [in] gvec_k List of G-vectors.
!> @param [out] evc Wave-functions.
!> @param [in] ld1 Leading dimention of evc array.
!> @param [in] ld2 Second dimention of evc array.
subroutine sirius_get_wave_functions(ks_handler,ik,ispn,npw,gvec_k,evc,ld1,ld2)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, intent(in) :: ik
integer, intent(in) :: ispn
integer, intent(in) :: npw
integer, intent(in) :: gvec_k
complex(8), intent(out) :: evc
integer, intent(in) :: ld1
integer, intent(in) :: ld2
!
!
interface
subroutine sirius_get_wave_functions_aux(ks_handler,ik,ispn,npw,gvec_k,evc,ld1,ld2)&
&bind(C, name="sirius_get_wave_functions")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT), intent(in) :: ik
integer(C_INT), intent(in) :: ispn
integer(C_INT), intent(in) :: npw
integer(C_INT), intent(in) :: gvec_k
complex(C_DOUBLE), intent(out) :: evc
integer(C_INT), intent(in) :: ld1
integer(C_INT), intent(in) :: ld2
end subroutine
end interface

call sirius_get_wave_functions_aux(ks_handler,ik,ispn,npw,gvec_k,evc,ld1,ld2)
end subroutine sirius_get_wave_functions

!
!> @brief Get value of the radial integral.
!> @param [in] handler Simulation context handler.
!> @param [in] atom_type Label of the atom type.
!> @param [in] label Label of the radial integral.
!> @param [in] q Length of the reciprocal wave-vector.
!> @param [in] idx Index of the radial integral.
!> @param [in] l Orbital quantum number (for Q-radial integrals).
function sirius_get_radial_integral(handler,atom_type,label,q,idx,l) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: atom_type
character(*), intent(in) :: label
real(8), intent(in) :: q
integer, intent(in) :: idx
integer, optional, target, intent(in) :: l
real(8) :: res
!
character(C_CHAR), target, allocatable :: atom_type_c_type(:)
type(C_PTR) :: atom_type_ptr
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: l_ptr
!
interface
function sirius_get_radial_integral_aux(handler,atom_type,label,q,idx,l) result(res)&
&bind(C, name="sirius_get_radial_integral")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: atom_type
type(C_PTR), value :: label
real(C_DOUBLE), intent(in) :: q
integer(C_INT), intent(in) :: idx
type(C_PTR), value :: l
real(C_DOUBLE) :: res
end function
end interface

atom_type_ptr = C_NULL_PTR
allocate(atom_type_c_type(len(atom_type)+1))
atom_type_c_type = string(atom_type)
atom_type_ptr = C_LOC(atom_type_c_type)
label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
l_ptr = C_NULL_PTR
if (present(l)) l_ptr = C_LOC(l)

res = sirius_get_radial_integral_aux(handler,atom_type_ptr,label_ptr,q,idx,l_ptr)
if (allocated(atom_type_c_type)) deallocate(atom_type_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end function sirius_get_radial_integral

!
!> @brief Compute occupation matrix.
!> @param [in] handler Ground state handler.
subroutine sirius_calculate_hubbard_occupancies(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_calculate_hubbard_occupancies_aux(handler)&
&bind(C, name="sirius_calculate_hubbard_occupancies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_calculate_hubbard_occupancies_aux(handler)
end subroutine sirius_calculate_hubbard_occupancies

!
!> @brief Set occupation matrix for LDA+U.
!> @param [in] handler Ground state handler.
!> @param [inout] occ Occupation matrix.
!> @param [in] ld Leading dimensions of the occupation matrix.
subroutine sirius_set_hubbard_occupancies(handler,occ,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
complex(8), intent(inout) :: occ
integer, intent(in) :: ld
!
!
interface
subroutine sirius_set_hubbard_occupancies_aux(handler,occ,ld)&
&bind(C, name="sirius_set_hubbard_occupancies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
complex(C_DOUBLE), intent(inout) :: occ
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_set_hubbard_occupancies_aux(handler,occ,ld)
end subroutine sirius_set_hubbard_occupancies

!
!> @brief Get occupation matrix for LDA+U.
!> @param [in] handler Ground state handler.
!> @param [inout] occ Occupation matrix.
!> @param [in] ld Leading dimensions of the occupation matrix.
subroutine sirius_get_hubbard_occupancies(handler,occ,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
complex(8), intent(inout) :: occ
integer, intent(in) :: ld
!
!
interface
subroutine sirius_get_hubbard_occupancies_aux(handler,occ,ld)&
&bind(C, name="sirius_get_hubbard_occupancies")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
complex(C_DOUBLE), intent(inout) :: occ
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_get_hubbard_occupancies_aux(handler,occ,ld)
end subroutine sirius_get_hubbard_occupancies

!
!> @brief Set LDA+U potential matrix.
!> @param [in] handler Ground state handler.
!> @param [inout] pot Potential correction matrix.
!> @param [in] ld Leading dimensions of the matrix.
subroutine sirius_set_hubbard_potential(handler,pot,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
complex(8), intent(inout) :: pot
integer, intent(in) :: ld
!
!
interface
subroutine sirius_set_hubbard_potential_aux(handler,pot,ld)&
&bind(C, name="sirius_set_hubbard_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
complex(C_DOUBLE), intent(inout) :: pot
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_set_hubbard_potential_aux(handler,pot,ld)
end subroutine sirius_set_hubbard_potential

!
!> @brief Set LDA+U potential matrix.
!> @param [in] handler Ground state handler.
!> @param [inout] pot Potential correction matrix.
!> @param [in] ld Leading dimensions of the matrix.
subroutine sirius_get_hubbard_potential(handler,pot,ld)
implicit none
!
type(C_PTR), intent(in) :: handler
complex(8), intent(inout) :: pot
integer, intent(in) :: ld
!
!
interface
subroutine sirius_get_hubbard_potential_aux(handler,pot,ld)&
&bind(C, name="sirius_get_hubbard_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
complex(C_DOUBLE), intent(inout) :: pot
integer(C_INT), intent(in) :: ld
end subroutine
end interface

call sirius_get_hubbard_potential_aux(handler,pot,ld)
end subroutine sirius_get_hubbard_potential

!
!> @brief Add descriptor of the augmented wave radial function.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] n Principal quantum number.
!> @param [in] l Orbital quantum number.
!> @param [in] enu Linearization energy.
!> @param [in] dme Order of energy derivative.
!> @param [in] auto_enu True if automatic search of linearization energy is allowed for this radial solution.
subroutine sirius_add_atom_type_aw_descriptor(handler,label,n,l,enu,dme,auto_enu)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: n
integer, intent(in) :: l
real(8), intent(in) :: enu
integer, intent(in) :: dme
logical, intent(in) :: auto_enu
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: auto_enu_c_type
!
interface
subroutine sirius_add_atom_type_aw_descriptor_aux(handler,label,n,l,enu,dme,auto_enu)&
&bind(C, name="sirius_add_atom_type_aw_descriptor")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: n
integer(C_INT), intent(in) :: l
real(C_DOUBLE), intent(in) :: enu
integer(C_INT), intent(in) :: dme
logical(C_BOOL), intent(in) :: auto_enu
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
auto_enu_c_type = bool(auto_enu)
call sirius_add_atom_type_aw_descriptor_aux(handler,label_ptr,n,l,enu,dme,auto_enu_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_add_atom_type_aw_descriptor

!
!> @brief Add descriptor of the local orbital radial function.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] ilo Index of the local orbital to which the descriptro is added.
!> @param [in] n Principal quantum number.
!> @param [in] l Orbital quantum number.
!> @param [in] enu Linearization energy.
!> @param [in] dme Order of energy derivative.
!> @param [in] auto_enu True if automatic search of linearization energy is allowed for this radial solution.
subroutine sirius_add_atom_type_lo_descriptor(handler,label,ilo,n,l,enu,dme,auto_enu)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: ilo
integer, intent(in) :: n
integer, intent(in) :: l
real(8), intent(in) :: enu
integer, intent(in) :: dme
logical, intent(in) :: auto_enu
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: auto_enu_c_type
!
interface
subroutine sirius_add_atom_type_lo_descriptor_aux(handler,label,ilo,n,l,enu,dme,&
&auto_enu)&
&bind(C, name="sirius_add_atom_type_lo_descriptor")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: ilo
integer(C_INT), intent(in) :: n
integer(C_INT), intent(in) :: l
real(C_DOUBLE), intent(in) :: enu
integer(C_INT), intent(in) :: dme
logical(C_BOOL), intent(in) :: auto_enu
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
auto_enu_c_type = bool(auto_enu)
call sirius_add_atom_type_lo_descriptor_aux(handler,label_ptr,ilo,n,l,enu,dme,auto_enu_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_add_atom_type_lo_descriptor

!
!> @brief Set configuration of atomic levels.
!> @param [in] handler Simulation context handler.
!> @param [in] label Atom type label.
!> @param [in] n Principal quantum number.
!> @param [in] l Orbital quantum number.
!> @param [in] k kappa (used in relativistic solver).
!> @param [in] occupancy Level occupancy.
!> @param [in] core Tru if this is a core state.
subroutine sirius_set_atom_type_configuration(handler,label,n,l,k,occupancy,core)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: n
integer, intent(in) :: l
integer, intent(in) :: k
real(8), intent(in) :: occupancy
logical, intent(in) :: core
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: core_c_type
!
interface
subroutine sirius_set_atom_type_configuration_aux(handler,label,n,l,k,occupancy,&
&core)&
&bind(C, name="sirius_set_atom_type_configuration")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: n
integer(C_INT), intent(in) :: l
integer(C_INT), intent(in) :: k
real(C_DOUBLE), intent(in) :: occupancy
logical(C_BOOL), intent(in) :: core
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
core_c_type = bool(core)
call sirius_set_atom_type_configuration_aux(handler,label_ptr,n,l,k,occupancy,core_c_type)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_atom_type_configuration

!
!> @brief Generate Coulomb potential by solving Poisson equation
!> @param [in] handler Ground state handler
!> @param [in] is_local_rg true if regular grid pointer is local
!> @param [out] vclmt Muffin-tin part of potential
!> @param [out] vclrg Regular-grid part of potential
subroutine sirius_generate_coulomb_potential(handler,is_local_rg,vclmt,vclrg)
implicit none
!
type(C_PTR), intent(in) :: handler
logical, intent(in) :: is_local_rg
real(8), intent(out) :: vclmt
real(8), intent(out) :: vclrg
!
logical(C_BOOL), target :: is_local_rg_c_type
!
interface
subroutine sirius_generate_coulomb_potential_aux(handler,is_local_rg,vclmt,vclrg)&
&bind(C, name="sirius_generate_coulomb_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
logical(C_BOOL), intent(in) :: is_local_rg
real(C_DOUBLE), intent(out) :: vclmt
real(C_DOUBLE), intent(out) :: vclrg
end subroutine
end interface

is_local_rg_c_type = bool(is_local_rg)
call sirius_generate_coulomb_potential_aux(handler,is_local_rg_c_type,vclmt,vclrg)
end subroutine sirius_generate_coulomb_potential

!
!> @brief Generate XC potential using LibXC
!> @param [in] handler Ground state handler
!> @param [in] is_local_rg true if regular grid pointer is local
!> @param [out] vxcmt Muffin-tin part of potential
!> @param [out] vxcrg Regular-grid part of potential
!> @param [out] bxcmt_x Muffin-tin part of effective magentic field (x-component)
!> @param [out] bxcmt_y Muffin-tin part of effective magentic field (y-component)
!> @param [out] bxcmt_z Muffin-tin part of effective magentic field (z-component)
!> @param [out] bxcrg_x Regular-grid part of effective magnetic field (x-component)
!> @param [out] bxcrg_y Regular-grid part of effective magnetic field (y-component)
!> @param [out] bxcrg_z Regular-grid part of effective magnetic field (z-component)
subroutine sirius_generate_xc_potential(handler,is_local_rg,vxcmt,vxcrg,bxcmt_x,&
&bxcmt_y,bxcmt_z,bxcrg_x,bxcrg_y,bxcrg_z)
implicit none
!
type(C_PTR), intent(in) :: handler
logical, intent(in) :: is_local_rg
real(8), intent(out) :: vxcmt
real(8), intent(out) :: vxcrg
real(8), optional, target, intent(out) :: bxcmt_x
real(8), optional, target, intent(out) :: bxcmt_y
real(8), optional, target, intent(out) :: bxcmt_z
real(8), optional, target, intent(out) :: bxcrg_x
real(8), optional, target, intent(out) :: bxcrg_y
real(8), optional, target, intent(out) :: bxcrg_z
!
logical(C_BOOL), target :: is_local_rg_c_type
type(C_PTR) :: bxcmt_x_ptr
type(C_PTR) :: bxcmt_y_ptr
type(C_PTR) :: bxcmt_z_ptr
type(C_PTR) :: bxcrg_x_ptr
type(C_PTR) :: bxcrg_y_ptr
type(C_PTR) :: bxcrg_z_ptr
!
interface
subroutine sirius_generate_xc_potential_aux(handler,is_local_rg,vxcmt,vxcrg,bxcmt_x,&
&bxcmt_y,bxcmt_z,bxcrg_x,bxcrg_y,bxcrg_z)&
&bind(C, name="sirius_generate_xc_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
logical(C_BOOL), intent(in) :: is_local_rg
real(C_DOUBLE), intent(out) :: vxcmt
real(C_DOUBLE), intent(out) :: vxcrg
type(C_PTR), value :: bxcmt_x
type(C_PTR), value :: bxcmt_y
type(C_PTR), value :: bxcmt_z
type(C_PTR), value :: bxcrg_x
type(C_PTR), value :: bxcrg_y
type(C_PTR), value :: bxcrg_z
end subroutine
end interface

is_local_rg_c_type = bool(is_local_rg)
bxcmt_x_ptr = C_NULL_PTR
if (present(bxcmt_x)) bxcmt_x_ptr = C_LOC(bxcmt_x)

bxcmt_y_ptr = C_NULL_PTR
if (present(bxcmt_y)) bxcmt_y_ptr = C_LOC(bxcmt_y)

bxcmt_z_ptr = C_NULL_PTR
if (present(bxcmt_z)) bxcmt_z_ptr = C_LOC(bxcmt_z)

bxcrg_x_ptr = C_NULL_PTR
if (present(bxcrg_x)) bxcrg_x_ptr = C_LOC(bxcrg_x)

bxcrg_y_ptr = C_NULL_PTR
if (present(bxcrg_y)) bxcrg_y_ptr = C_LOC(bxcrg_y)

bxcrg_z_ptr = C_NULL_PTR
if (present(bxcrg_z)) bxcrg_z_ptr = C_LOC(bxcrg_z)

call sirius_generate_xc_potential_aux(handler,is_local_rg_c_type,vxcmt,vxcrg,bxcmt_x_ptr,&
&bxcmt_y_ptr,bxcmt_z_ptr,bxcrg_x_ptr,bxcrg_y_ptr,bxcrg_z_ptr)
end subroutine sirius_generate_xc_potential

!
!> @brief Get communicator which is used to split k-points
!> @param [in] handler Simulation context handler
!> @param [out] fcomm Fortran communicator
subroutine sirius_get_kpoint_inter_comm(handler,fcomm)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: fcomm
!
!
interface
subroutine sirius_get_kpoint_inter_comm_aux(handler,fcomm)&
&bind(C, name="sirius_get_kpoint_inter_comm")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: fcomm
end subroutine
end interface

call sirius_get_kpoint_inter_comm_aux(handler,fcomm)
end subroutine sirius_get_kpoint_inter_comm

!
!> @brief Get communicator which is used to parallise band problem
!> @param [in] handler Simulation context handler
!> @param [out] fcomm Fortran communicator
subroutine sirius_get_kpoint_inner_comm(handler,fcomm)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: fcomm
!
!
interface
subroutine sirius_get_kpoint_inner_comm_aux(handler,fcomm)&
&bind(C, name="sirius_get_kpoint_inner_comm")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: fcomm
end subroutine
end interface

call sirius_get_kpoint_inner_comm_aux(handler,fcomm)
end subroutine sirius_get_kpoint_inner_comm

!
!> @brief Get communicator which is used to parallise FFT
!> @param [in] handler Simulation context handler
!> @param [out] fcomm Fortran communicator
subroutine sirius_get_fft_comm(handler,fcomm)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: fcomm
!
!
interface
subroutine sirius_get_fft_comm_aux(handler,fcomm)&
&bind(C, name="sirius_get_fft_comm")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: fcomm
end subroutine
end interface

call sirius_get_fft_comm_aux(handler,fcomm)
end subroutine sirius_get_fft_comm

!
!> @brief Get total number of G-vectors
!> @param [in] handler Simulation context handler
function sirius_get_num_gvec(handler) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
integer :: res
!
!
interface
function sirius_get_num_gvec_aux(handler) result(res)&
&bind(C, name="sirius_get_num_gvec")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT) :: res
end function
end interface

res = sirius_get_num_gvec_aux(handler)
end function sirius_get_num_gvec

!
!> @brief Get G-vector arrays.
!> @param [in] handler Simulation context handler
!> @param [in] gvec G-vectors in lattice coordinates.
!> @param [in] gvec_cart G-vectors in Cartesian coordinates.
!> @param [in] gvec_len Length of G-vectors.
!> @param [in] index_by_gvec G-vector index by lattice coordinates.
subroutine sirius_get_gvec_arrays(handler,gvec,gvec_cart,gvec_len,index_by_gvec)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, optional, target, intent(in) :: gvec
real(8), optional, target, intent(in) :: gvec_cart
real(8), optional, target, intent(in) :: gvec_len
integer, optional, target, intent(in) :: index_by_gvec
!
type(C_PTR) :: gvec_ptr
type(C_PTR) :: gvec_cart_ptr
type(C_PTR) :: gvec_len_ptr
type(C_PTR) :: index_by_gvec_ptr
!
interface
subroutine sirius_get_gvec_arrays_aux(handler,gvec,gvec_cart,gvec_len,index_by_gvec)&
&bind(C, name="sirius_get_gvec_arrays")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: gvec
type(C_PTR), value :: gvec_cart
type(C_PTR), value :: gvec_len
type(C_PTR), value :: index_by_gvec
end subroutine
end interface

gvec_ptr = C_NULL_PTR
if (present(gvec)) gvec_ptr = C_LOC(gvec)

gvec_cart_ptr = C_NULL_PTR
if (present(gvec_cart)) gvec_cart_ptr = C_LOC(gvec_cart)

gvec_len_ptr = C_NULL_PTR
if (present(gvec_len)) gvec_len_ptr = C_LOC(gvec_len)

index_by_gvec_ptr = C_NULL_PTR
if (present(index_by_gvec)) index_by_gvec_ptr = C_LOC(index_by_gvec)

call sirius_get_gvec_arrays_aux(handler,gvec_ptr,gvec_cart_ptr,gvec_len_ptr,index_by_gvec_ptr)
end subroutine sirius_get_gvec_arrays

!
!> @brief Get local number of FFT grid points.
!> @param [in] handler Simulation context handler
function sirius_get_num_fft_grid_points(handler) result(res)
implicit none
!
type(C_PTR), intent(in) :: handler
integer :: res
!
!
interface
function sirius_get_num_fft_grid_points_aux(handler) result(res)&
&bind(C, name="sirius_get_num_fft_grid_points")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT) :: res
end function
end interface

res = sirius_get_num_fft_grid_points_aux(handler)
end function sirius_get_num_fft_grid_points

!
!> @brief Get mapping between G-vector index and FFT index
!> @param [in] handler Simulation context handler
!> @param [out] fft_index Index inside FFT buffer
subroutine sirius_get_fft_index(handler,fft_index)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: fft_index
!
!
interface
subroutine sirius_get_fft_index_aux(handler,fft_index)&
&bind(C, name="sirius_get_fft_index")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: fft_index
end subroutine
end interface

call sirius_get_fft_index_aux(handler,fft_index)
end subroutine sirius_get_fft_index

!
!> @brief Get maximum number of G+k vectors across all k-points in the set
!> @param [in] ks_handler K-point set handler.
function sirius_get_max_num_gkvec(ks_handler) result(res)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer :: res
!
!
interface
function sirius_get_max_num_gkvec_aux(ks_handler) result(res)&
&bind(C, name="sirius_get_max_num_gkvec")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT) :: res
end function
end interface

res = sirius_get_max_num_gkvec_aux(ks_handler)
end function sirius_get_max_num_gkvec

!
!> @brief Get all G+k vector related arrays
!> @param [in] ks_handler K-point set handler.
!> @param [in] ik Global index of k-point
!> @param [out] num_gkvec Number of G+k vectors.
!> @param [out] gvec_index Index of the G-vector part of G+k vector.
!> @param [out] gkvec G+k vectors in fractional coordinates.
!> @param [out] gkvec_cart G+k vectors in Cartesian coordinates.
!> @param [out] gkvec_len Length of G+k vectors.
!> @param [out] gkvec_tp Theta and Phi angles of G+k vectors.
subroutine sirius_get_gkvec_arrays(ks_handler,ik,num_gkvec,gvec_index,gkvec,gkvec_cart,&
&gkvec_len,gkvec_tp)
implicit none
!
type(C_PTR), intent(in) :: ks_handler
integer, intent(in) :: ik
integer, intent(out) :: num_gkvec
integer, intent(out) :: gvec_index
real(8), intent(out) :: gkvec
real(8), intent(out) :: gkvec_cart
real(8), intent(out) :: gkvec_len
real(8), intent(out) :: gkvec_tp
!
!
interface
subroutine sirius_get_gkvec_arrays_aux(ks_handler,ik,num_gkvec,gvec_index,gkvec,&
&gkvec_cart,gkvec_len,gkvec_tp)&
&bind(C, name="sirius_get_gkvec_arrays")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: ks_handler
integer(C_INT), intent(in) :: ik
integer(C_INT), intent(out) :: num_gkvec
integer(C_INT), intent(out) :: gvec_index
real(C_DOUBLE), intent(out) :: gkvec
real(C_DOUBLE), intent(out) :: gkvec_cart
real(C_DOUBLE), intent(out) :: gkvec_len
real(C_DOUBLE), intent(out) :: gkvec_tp
end subroutine
end interface

call sirius_get_gkvec_arrays_aux(ks_handler,ik,num_gkvec,gvec_index,gkvec,gkvec_cart,&
&gkvec_len,gkvec_tp)
end subroutine sirius_get_gkvec_arrays

!
!> @brief Get the unit-step function.
!> @param [in] handler Simulation context handler
!> @param [out] cfunig Plane-wave coefficients of step function.
!> @param [out] cfunrg Values of the step function on the regular grid.
subroutine sirius_get_step_function(handler,cfunig,cfunrg)
implicit none
!
type(C_PTR), intent(in) :: handler
complex(8), intent(out) :: cfunig
real(8), intent(out) :: cfunrg
!
!
interface
subroutine sirius_get_step_function_aux(handler,cfunig,cfunrg)&
&bind(C, name="sirius_get_step_function")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
complex(C_DOUBLE), intent(out) :: cfunig
real(C_DOUBLE), intent(out) :: cfunrg
end subroutine
end interface

call sirius_get_step_function_aux(handler,cfunig,cfunrg)
end subroutine sirius_get_step_function

!
!> @brief Get electronic part of Hartree potential at atom origins.
!> @param [in] handler DFT ground state handler.
!> @param [out] vha_el Electronic part of Hartree potential at each atom's origin.
subroutine sirius_get_vha_el(handler,vha_el)
implicit none
!
type(C_PTR), intent(in) :: handler
real(8), intent(out) :: vha_el
!
!
interface
subroutine sirius_get_vha_el_aux(handler,vha_el)&
&bind(C, name="sirius_get_vha_el")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
real(C_DOUBLE), intent(out) :: vha_el
end subroutine
end interface

call sirius_get_vha_el_aux(handler,vha_el)
end subroutine sirius_get_vha_el

!
!> @brief Set LAPW Hamiltonian radial integrals.
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] lmmax Number of lm-component of the potential.
!> @param [in] val Values of the radial integrals.
!> @param [in] l1 1st index of orbital quantum number.
!> @param [in] o1 1st index of radial function order for l1.
!> @param [in] ilo1 1st index or local orbital.
!> @param [in] l2 2nd index of orbital quantum number.
!> @param [in] o2 2nd index of radial function order for l2.
!> @param [in] ilo2 2nd index or local orbital.
subroutine sirius_set_h_radial_integrals(handler,ia,lmmax,val,l1,o1,ilo1,l2,o2,ilo2)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
integer, intent(in) :: lmmax
real(8), intent(in) :: val
integer, optional, target, intent(in) :: l1
integer, optional, target, intent(in) :: o1
integer, optional, target, intent(in) :: ilo1
integer, optional, target, intent(in) :: l2
integer, optional, target, intent(in) :: o2
integer, optional, target, intent(in) :: ilo2
!
type(C_PTR) :: l1_ptr
type(C_PTR) :: o1_ptr
type(C_PTR) :: ilo1_ptr
type(C_PTR) :: l2_ptr
type(C_PTR) :: o2_ptr
type(C_PTR) :: ilo2_ptr
!
interface
subroutine sirius_set_h_radial_integrals_aux(handler,ia,lmmax,val,l1,o1,ilo1,l2,&
&o2,ilo2)&
&bind(C, name="sirius_set_h_radial_integrals")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
integer(C_INT), intent(in) :: lmmax
real(C_DOUBLE), intent(in) :: val
type(C_PTR), value :: l1
type(C_PTR), value :: o1
type(C_PTR), value :: ilo1
type(C_PTR), value :: l2
type(C_PTR), value :: o2
type(C_PTR), value :: ilo2
end subroutine
end interface

l1_ptr = C_NULL_PTR
if (present(l1)) l1_ptr = C_LOC(l1)

o1_ptr = C_NULL_PTR
if (present(o1)) o1_ptr = C_LOC(o1)

ilo1_ptr = C_NULL_PTR
if (present(ilo1)) ilo1_ptr = C_LOC(ilo1)

l2_ptr = C_NULL_PTR
if (present(l2)) l2_ptr = C_LOC(l2)

o2_ptr = C_NULL_PTR
if (present(o2)) o2_ptr = C_LOC(o2)

ilo2_ptr = C_NULL_PTR
if (present(ilo2)) ilo2_ptr = C_LOC(ilo2)

call sirius_set_h_radial_integrals_aux(handler,ia,lmmax,val,l1_ptr,o1_ptr,ilo1_ptr,&
&l2_ptr,o2_ptr,ilo2_ptr)
end subroutine sirius_set_h_radial_integrals

!
!> @brief Set LAPW overlap radial integral.
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] val Value of the radial integral.
!> @param [in] l Orbital quantum number.
!> @param [in] o1 1st index of radial function order.
!> @param [in] ilo1 1st index or local orbital.
!> @param [in] o2 2nd index of radial function order.
!> @param [in] ilo2 2nd index or local orbital.
subroutine sirius_set_o_radial_integral(handler,ia,val,l,o1,ilo1,o2,ilo2)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
real(8), intent(in) :: val
integer, intent(in) :: l
integer, optional, target, intent(in) :: o1
integer, optional, target, intent(in) :: ilo1
integer, optional, target, intent(in) :: o2
integer, optional, target, intent(in) :: ilo2
!
type(C_PTR) :: o1_ptr
type(C_PTR) :: ilo1_ptr
type(C_PTR) :: o2_ptr
type(C_PTR) :: ilo2_ptr
!
interface
subroutine sirius_set_o_radial_integral_aux(handler,ia,val,l,o1,ilo1,o2,ilo2)&
&bind(C, name="sirius_set_o_radial_integral")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
real(C_DOUBLE), intent(in) :: val
integer(C_INT), intent(in) :: l
type(C_PTR), value :: o1
type(C_PTR), value :: ilo1
type(C_PTR), value :: o2
type(C_PTR), value :: ilo2
end subroutine
end interface

o1_ptr = C_NULL_PTR
if (present(o1)) o1_ptr = C_LOC(o1)

ilo1_ptr = C_NULL_PTR
if (present(ilo1)) ilo1_ptr = C_LOC(ilo1)

o2_ptr = C_NULL_PTR
if (present(o2)) o2_ptr = C_LOC(o2)

ilo2_ptr = C_NULL_PTR
if (present(ilo2)) ilo2_ptr = C_LOC(ilo2)

call sirius_set_o_radial_integral_aux(handler,ia,val,l,o1_ptr,ilo1_ptr,o2_ptr,ilo2_ptr)
end subroutine sirius_set_o_radial_integral

!
!> @brief Set a correction to LAPW overlap radial integral.
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] val Value of the radial integral.
!> @param [in] l1 1st index of orbital quantum number.
!> @param [in] o1 1st index of radial function order for l1.
!> @param [in] ilo1 1st index or local orbital.
!> @param [in] l2 2nd index of orbital quantum number.
!> @param [in] o2 2nd index of radial function order for l2.
!> @param [in] ilo2 2nd index or local orbital.
subroutine sirius_set_o1_radial_integral(handler,ia,val,l1,o1,ilo1,l2,o2,ilo2)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
real(8), intent(in) :: val
integer, optional, target, intent(in) :: l1
integer, optional, target, intent(in) :: o1
integer, optional, target, intent(in) :: ilo1
integer, optional, target, intent(in) :: l2
integer, optional, target, intent(in) :: o2
integer, optional, target, intent(in) :: ilo2
!
type(C_PTR) :: l1_ptr
type(C_PTR) :: o1_ptr
type(C_PTR) :: ilo1_ptr
type(C_PTR) :: l2_ptr
type(C_PTR) :: o2_ptr
type(C_PTR) :: ilo2_ptr
!
interface
subroutine sirius_set_o1_radial_integral_aux(handler,ia,val,l1,o1,ilo1,l2,o2,ilo2)&
&bind(C, name="sirius_set_o1_radial_integral")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
real(C_DOUBLE), intent(in) :: val
type(C_PTR), value :: l1
type(C_PTR), value :: o1
type(C_PTR), value :: ilo1
type(C_PTR), value :: l2
type(C_PTR), value :: o2
type(C_PTR), value :: ilo2
end subroutine
end interface

l1_ptr = C_NULL_PTR
if (present(l1)) l1_ptr = C_LOC(l1)

o1_ptr = C_NULL_PTR
if (present(o1)) o1_ptr = C_LOC(o1)

ilo1_ptr = C_NULL_PTR
if (present(ilo1)) ilo1_ptr = C_LOC(ilo1)

l2_ptr = C_NULL_PTR
if (present(l2)) l2_ptr = C_LOC(l2)

o2_ptr = C_NULL_PTR
if (present(o2)) o2_ptr = C_LOC(o2)

ilo2_ptr = C_NULL_PTR
if (present(ilo2)) ilo2_ptr = C_LOC(ilo2)

call sirius_set_o1_radial_integral_aux(handler,ia,val,l1_ptr,o1_ptr,ilo1_ptr,l2_ptr,&
&o2_ptr,ilo2_ptr)
end subroutine sirius_set_o1_radial_integral

!
!> @brief Set LAPW radial functions
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] deriv_order Radial derivative order.
!> @param [in] f Values of the radial function.
!> @param [in] l Orbital quantum number.
!> @param [in] o Order of radial function for l.
!> @param [in] ilo Local orbital index.
subroutine sirius_set_radial_function(handler,ia,deriv_order,f,l,o,ilo)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
integer, intent(in) :: deriv_order
real(8), intent(in) :: f
integer, optional, target, intent(in) :: l
integer, optional, target, intent(in) :: o
integer, optional, target, intent(in) :: ilo
!
type(C_PTR) :: l_ptr
type(C_PTR) :: o_ptr
type(C_PTR) :: ilo_ptr
!
interface
subroutine sirius_set_radial_function_aux(handler,ia,deriv_order,f,l,o,ilo)&
&bind(C, name="sirius_set_radial_function")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
integer(C_INT), intent(in) :: deriv_order
real(C_DOUBLE), intent(in) :: f
type(C_PTR), value :: l
type(C_PTR), value :: o
type(C_PTR), value :: ilo
end subroutine
end interface

l_ptr = C_NULL_PTR
if (present(l)) l_ptr = C_LOC(l)

o_ptr = C_NULL_PTR
if (present(o)) o_ptr = C_LOC(o)

ilo_ptr = C_NULL_PTR
if (present(ilo)) ilo_ptr = C_LOC(ilo)

call sirius_set_radial_function_aux(handler,ia,deriv_order,f,l_ptr,o_ptr,ilo_ptr)
end subroutine sirius_set_radial_function

!
!> @brief Get LAPW radial functions
!> @param [in] handler Simulation context handler.
!> @param [in] ia Index of atom.
!> @param [in] deriv_order Radial derivative order.
!> @param [out] f Values of the radial function.
!> @param [in] l Orbital quantum number.
!> @param [in] o Order of radial function for l.
!> @param [in] ilo Local orbital index.
subroutine sirius_get_radial_function(handler,ia,deriv_order,f,l,o,ilo)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ia
integer, intent(in) :: deriv_order
real(8), intent(out) :: f
integer, optional, target, intent(in) :: l
integer, optional, target, intent(in) :: o
integer, optional, target, intent(in) :: ilo
!
type(C_PTR) :: l_ptr
type(C_PTR) :: o_ptr
type(C_PTR) :: ilo_ptr
!
interface
subroutine sirius_get_radial_function_aux(handler,ia,deriv_order,f,l,o,ilo)&
&bind(C, name="sirius_get_radial_function")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ia
integer(C_INT), intent(in) :: deriv_order
real(C_DOUBLE), intent(out) :: f
type(C_PTR), value :: l
type(C_PTR), value :: o
type(C_PTR), value :: ilo
end subroutine
end interface

l_ptr = C_NULL_PTR
if (present(l)) l_ptr = C_LOC(l)

o_ptr = C_NULL_PTR
if (present(o)) o_ptr = C_LOC(o)

ilo_ptr = C_NULL_PTR
if (present(ilo)) ilo_ptr = C_LOC(ilo)

call sirius_get_radial_function_aux(handler,ia,deriv_order,f,l_ptr,o_ptr,ilo_ptr)
end subroutine sirius_get_radial_function

!
!> @brief Set equivalent atoms.
!> @param [in] handler Simulation context handler.
!> @param [in] equivalent_atoms Array with equivalent atom IDs.
subroutine sirius_set_equivalent_atoms(handler,equivalent_atoms)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: equivalent_atoms
!
!
interface
subroutine sirius_set_equivalent_atoms_aux(handler,equivalent_atoms)&
&bind(C, name="sirius_set_equivalent_atoms")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: equivalent_atoms
end subroutine
end interface

call sirius_set_equivalent_atoms_aux(handler,equivalent_atoms)
end subroutine sirius_set_equivalent_atoms

!
!> @brief Set the new spherical potential.
!> @param [in] handler Ground state handler.
subroutine sirius_update_atomic_potential(handler)
implicit none
!
type(C_PTR), intent(in) :: handler
!
!
interface
subroutine sirius_update_atomic_potential_aux(handler)&
&bind(C, name="sirius_update_atomic_potential")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
end subroutine
end interface

call sirius_update_atomic_potential_aux(handler)
end subroutine sirius_update_atomic_potential

!
!> @brief return the number of options in a given section
!> @param [in] section name of the seciton
!> @param [out] length number of options contained in  the section
subroutine sirius_option_get_length(section,length)
implicit none
!
character(*), intent(in) :: section
integer, intent(out) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
!
interface
subroutine sirius_option_get_length_aux(section,length)&
&bind(C, name="sirius_option_get_length")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
integer(C_INT), intent(out) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
call sirius_option_get_length_aux(section_ptr,length)
if (allocated(section_c_type)) deallocate(section_c_type)
end subroutine sirius_option_get_length

!
!> @brief Return the name and a type of an option from its index.
!> @param [in] section Name of the section.
!> @param [in] elem Index of the option.
!> @param [out] key_name Name of the option.
!> @param [out] type Type of the option (real, integer, boolean, string).
subroutine sirius_option_get_name_and_type(section,elem,key_name,type)
implicit none
!
character(*), intent(in) :: section
integer, intent(in) :: elem
character(*), intent(out) :: key_name
integer, intent(out) :: type
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: key_name_c_type(:)
type(C_PTR) :: key_name_ptr
!
interface
subroutine sirius_option_get_name_and_type_aux(section,elem,key_name,type)&
&bind(C, name="sirius_option_get_name_and_type")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
integer(C_INT), intent(in) :: elem
type(C_PTR), value :: key_name
integer(C_INT), intent(out) :: type
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
key_name_ptr = C_NULL_PTR
allocate(key_name_c_type(len(key_name)+1))
key_name_c_type = string(key_name)
key_name_ptr = C_LOC(key_name_c_type)
call sirius_option_get_name_and_type_aux(section_ptr,elem,key_name_ptr,type)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(key_name_c_type)) deallocate(key_name_c_type)
end subroutine sirius_option_get_name_and_type

!
!> @brief return the description and usage of a given option
!> @param [in] section name of the section
!> @param [in] name name of the option
!> @param [out] desc description of the option
!> @param [out] usage how to use the option
subroutine sirius_option_get_description_usage(section,name,desc,usage)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
character(*), intent(out) :: desc
character(*), intent(out) :: usage
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
character(C_CHAR), target, allocatable :: desc_c_type(:)
type(C_PTR) :: desc_ptr
character(C_CHAR), target, allocatable :: usage_c_type(:)
type(C_PTR) :: usage_ptr
!
interface
subroutine sirius_option_get_description_usage_aux(section,name,desc,usage)&
&bind(C, name="sirius_option_get_description_usage")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
type(C_PTR), value :: desc
type(C_PTR), value :: usage
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
desc_ptr = C_NULL_PTR
allocate(desc_c_type(len(desc)+1))
desc_c_type = string(desc)
desc_ptr = C_LOC(desc_c_type)
usage_ptr = C_NULL_PTR
allocate(usage_c_type(len(usage)+1))
usage_c_type = string(usage)
usage_ptr = C_LOC(usage_c_type)
call sirius_option_get_description_usage_aux(section_ptr,name_ptr,desc_ptr,usage_ptr)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
if (allocated(desc_c_type)) deallocate(desc_c_type)
if (allocated(usage_c_type)) deallocate(usage_c_type)
end subroutine sirius_option_get_description_usage

!
!> @brief return the default value of the option
!> @param [in] section name of the section of interest
!> @param [in] name name of the element
!> @param [out] default_value table containing the default values (if vector)
!> @param [out] length length of the table containing the default values
subroutine sirius_option_get_int(section,name,default_value,length)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
integer, intent(out) :: default_value
integer, intent(out) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_get_int_aux(section,name,default_value,length)&
&bind(C, name="sirius_option_get_int")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
integer(C_INT), intent(out) :: default_value
integer(C_INT), intent(out) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_get_int_aux(section_ptr,name_ptr,default_value,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_get_int

!
!> @brief return the default value of the option
!> @param [in] section name of the section of interest
!> @param [in] name name of the element
!> @param [out] default_value table containing the default values (if vector)
!> @param [out] length length of the table containing the default values
subroutine sirius_option_get_double(section,name,default_value,length)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
real(8), intent(out) :: default_value
integer, intent(out) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_get_double_aux(section,name,default_value,length)&
&bind(C, name="sirius_option_get_double")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
real(C_DOUBLE), intent(out) :: default_value
integer(C_INT), intent(out) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_get_double_aux(section_ptr,name_ptr,default_value,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_get_double

!
!> @brief return the default value of the option
!> @param [in] section name of the section
!> @param [in] name name of the element
!> @param [out] default_value table containing the default values
!> @param [out] length length of the table containing the default values
subroutine sirius_option_get_logical(section,name,default_value,length)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
logical, intent(out) :: default_value
integer, intent(out) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
logical(C_BOOL), target :: default_value_c_type
!
interface
subroutine sirius_option_get_logical_aux(section,name,default_value,length)&
&bind(C, name="sirius_option_get_logical")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
logical(C_BOOL), intent(out) :: default_value
integer(C_INT), intent(out) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
default_value_c_type = bool(default_value)
call sirius_option_get_logical_aux(section_ptr,name_ptr,default_value_c_type,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_get_logical

!
!> @brief return the default value of the option
!> @param [in] section name of the section
!> @param [in] name name of the option
!> @param [out] default_value table containing the string
subroutine sirius_option_get_string(section,name,default_value)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
character(*), intent(out) :: default_value
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
character(C_CHAR), target, allocatable :: default_value_c_type(:)
type(C_PTR) :: default_value_ptr
!
interface
subroutine sirius_option_get_string_aux(section,name,default_value)&
&bind(C, name="sirius_option_get_string")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
type(C_PTR), value :: default_value
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
default_value_ptr = C_NULL_PTR
allocate(default_value_c_type(len(default_value)+1))
default_value_c_type = string(default_value)
default_value_ptr = C_LOC(default_value_c_type)
call sirius_option_get_string_aux(section_ptr,name_ptr,default_value_ptr)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
if (allocated(default_value_c_type)) deallocate(default_value_c_type)
end subroutine sirius_option_get_string

!
!> @brief return the number of possible values for a string option
!> @param [in] section name of the section
!> @param [in] name name of the option
!> @param [out] num_ number of elements
subroutine sirius_option_get_number_of_possible_values(section,name,num_)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
integer, intent(out) :: num_
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_get_number_of_possible_values_aux(section,name,num_)&
&bind(C, name="sirius_option_get_number_of_possible_values")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
integer(C_INT), intent(out) :: num_
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_get_number_of_possible_values_aux(section_ptr,name_ptr,num_)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_get_number_of_possible_values

!
!> @brief return the possible values for a string parameter
!> @param [in] section name of the section
!> @param [in] name name of the option
!> @param [in] elem_ index of the value
!> @param [out] value_n string containing the value
subroutine sirius_option_string_get_value(section,name,elem_,value_n)
implicit none
!
character(*), intent(in) :: section
character(*), intent(in) :: name
integer, intent(in) :: elem_
character(*), intent(out) :: value_n
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
character(C_CHAR), target, allocatable :: value_n_c_type(:)
type(C_PTR) :: value_n_ptr
!
interface
subroutine sirius_option_string_get_value_aux(section,name,elem_,value_n)&
&bind(C, name="sirius_option_string_get_value")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: section
type(C_PTR), value :: name
integer(C_INT), intent(in) :: elem_
type(C_PTR), value :: value_n
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
value_n_ptr = C_NULL_PTR
allocate(value_n_c_type(len(value_n)+1))
value_n_c_type = string(value_n)
value_n_ptr = C_LOC(value_n_c_type)
call sirius_option_string_get_value_aux(section_ptr,name_ptr,elem_,value_n_ptr)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
if (allocated(value_n_c_type)) deallocate(value_n_c_type)
end subroutine sirius_option_string_get_value

!
!> @brief return the name of a given section
!> @param [in] elem_ index of the section
!> @param [out] section_name name of the section
subroutine sirius_option_get_section_name(elem_,section_name)
implicit none
!
integer, intent(in) :: elem_
character(*), intent(out) :: section_name
!
character(C_CHAR), target, allocatable :: section_name_c_type(:)
type(C_PTR) :: section_name_ptr
!
interface
subroutine sirius_option_get_section_name_aux(elem_,section_name)&
&bind(C, name="sirius_option_get_section_name")
use, intrinsic :: ISO_C_BINDING
integer(C_INT), intent(in) :: elem_
type(C_PTR), value :: section_name
end subroutine
end interface

section_name_ptr = C_NULL_PTR
allocate(section_name_c_type(len(section_name)+1))
section_name_c_type = string(section_name)
section_name_ptr = C_LOC(section_name_c_type)
call sirius_option_get_section_name_aux(elem_,section_name_ptr)
if (allocated(section_name_c_type)) deallocate(section_name_c_type)
end subroutine sirius_option_get_section_name

!
!> @brief return the number of sections
!> @param [out] length number of sections
subroutine sirius_option_get_number_of_sections(length)
implicit none
!
integer, intent(out) :: length
!
!
interface
subroutine sirius_option_get_number_of_sections_aux(length)&
&bind(C, name="sirius_option_get_number_of_sections")
use, intrinsic :: ISO_C_BINDING
integer(C_INT), intent(out) :: length
end subroutine
end interface

call sirius_option_get_number_of_sections_aux(length)
end subroutine sirius_option_get_number_of_sections

!
!> @brief set the value of the option name in a  (internal) json dictionary
!> @param [in] handler Simulation context handler.
!> @param [in] section string containing the options in json format
!> @param [in] name name of the element to pick
!> @param [in] default_values table containing the values
!> @param [in] length length of the table containing the values
subroutine sirius_option_set_int(handler,section,name,default_values,length)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: section
character(*), intent(in) :: name
integer, intent(in) :: default_values
integer, intent(in) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_set_int_aux(handler,section,name,default_values,length)&
&bind(C, name="sirius_option_set_int")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: section
type(C_PTR), value :: name
integer(C_INT), intent(in) :: default_values
integer(C_INT), intent(in) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_set_int_aux(handler,section_ptr,name_ptr,default_values,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_set_int

!
!> @brief set the value of the option name in a (internal) json dictionary
!> @param [in] handler Simulation context handler.
!> @param [in] section name of the section
!> @param [in] name name of the element to pick
!> @param [in] default_values table containing the values
!> @param [in] length length of the table containing the values
subroutine sirius_option_set_double(handler,section,name,default_values,length)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: section
character(*), intent(in) :: name
real(8), intent(in) :: default_values
integer, intent(in) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_set_double_aux(handler,section,name,default_values,length)&
&bind(C, name="sirius_option_set_double")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: section
type(C_PTR), value :: name
real(C_DOUBLE), intent(in) :: default_values
integer(C_INT), intent(in) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_set_double_aux(handler,section_ptr,name_ptr,default_values,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_set_double

!
!> @brief set the value of the option name in a  (internal) json dictionary
!> @param [in] handler Simulation context handler.
!> @param [in] section name of the section
!> @param [in] name name of the element to pick
!> @param [in] default_values table containing the values
!> @param [in] length length of the table containing the values
subroutine sirius_option_set_logical(handler,section,name,default_values,length)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: section
character(*), intent(in) :: name
integer, intent(in) :: default_values
integer, intent(in) :: length
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
!
interface
subroutine sirius_option_set_logical_aux(handler,section,name,default_values,length)&
&bind(C, name="sirius_option_set_logical")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: section
type(C_PTR), value :: name
integer(C_INT), intent(in) :: default_values
integer(C_INT), intent(in) :: length
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
call sirius_option_set_logical_aux(handler,section_ptr,name_ptr,default_values,length)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
end subroutine sirius_option_set_logical

!
!> @brief set the value of the option name in a  (internal) json dictionary
!> @param [in] handler Simulation context handler.
!> @param [in] section name of the section
!> @param [in] name name of the element to pick
!> @param [in] default_values table containing the values
subroutine sirius_option_set_string(handler,section,name,default_values)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: section
character(*), intent(in) :: name
character(*), intent(in) :: default_values
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
character(C_CHAR), target, allocatable :: default_values_c_type(:)
type(C_PTR) :: default_values_ptr
!
interface
subroutine sirius_option_set_string_aux(handler,section,name,default_values)&
&bind(C, name="sirius_option_set_string")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: section
type(C_PTR), value :: name
type(C_PTR), value :: default_values
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
default_values_ptr = C_NULL_PTR
allocate(default_values_c_type(len(default_values)+1))
default_values_c_type = string(default_values)
default_values_ptr = C_LOC(default_values_c_type)
call sirius_option_set_string_aux(handler,section_ptr,name_ptr,default_values_ptr)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
if (allocated(default_values_c_type)) deallocate(default_values_c_type)
end subroutine sirius_option_set_string

!
!> @brief add a string value to the option in the json dictionary
!> @param [in] handler Simulation context handler.
!> @param [in] section name of the section
!> @param [in] name name of the element to pick
!> @param [in] default_values string to be added
subroutine sirius_option_add_string_to(handler,section,name,default_values)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: section
character(*), intent(in) :: name
character(*), intent(in) :: default_values
!
character(C_CHAR), target, allocatable :: section_c_type(:)
type(C_PTR) :: section_ptr
character(C_CHAR), target, allocatable :: name_c_type(:)
type(C_PTR) :: name_ptr
character(C_CHAR), target, allocatable :: default_values_c_type(:)
type(C_PTR) :: default_values_ptr
!
interface
subroutine sirius_option_add_string_to_aux(handler,section,name,default_values)&
&bind(C, name="sirius_option_add_string_to")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: section
type(C_PTR), value :: name
type(C_PTR), value :: default_values
end subroutine
end interface

section_ptr = C_NULL_PTR
allocate(section_c_type(len(section)+1))
section_c_type = string(section)
section_ptr = C_LOC(section_c_type)
name_ptr = C_NULL_PTR
allocate(name_c_type(len(name)+1))
name_c_type = string(name)
name_ptr = C_LOC(name_c_type)
default_values_ptr = C_NULL_PTR
allocate(default_values_c_type(len(default_values)+1))
default_values_c_type = string(default_values)
default_values_ptr = C_LOC(default_values_c_type)
call sirius_option_add_string_to_aux(handler,section_ptr,name_ptr,default_values_ptr)
if (allocated(section_c_type)) deallocate(section_c_type)
if (allocated(name_c_type)) deallocate(name_c_type)
if (allocated(default_values_c_type)) deallocate(default_values_c_type)
end subroutine sirius_option_add_string_to

!
!> @brief Dump the runtime setup in a file.
!> @param [in] handler Simulation context handler.
!> @param [in] filename String containing the name of the file.
subroutine sirius_dump_runtime_setup(handler,filename)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: filename
!
character(C_CHAR), target, allocatable :: filename_c_type(:)
type(C_PTR) :: filename_ptr
!
interface
subroutine sirius_dump_runtime_setup_aux(handler,filename)&
&bind(C, name="sirius_dump_runtime_setup")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: filename
end subroutine
end interface

filename_ptr = C_NULL_PTR
allocate(filename_c_type(len(filename)+1))
filename_c_type = string(filename)
filename_ptr = C_LOC(filename_c_type)
call sirius_dump_runtime_setup_aux(handler,filename_ptr)
if (allocated(filename_c_type)) deallocate(filename_c_type)
end subroutine sirius_dump_runtime_setup

!
!> @brief Get the first-variational eigen vectors
!> @param [in] handler K-point set handler
!> @param [in] ik Global index of the k-point
!> @param [out] fv_evec Output first-variational eigenvector array
!> @param [in] ld Leading dimension of fv_evec
!> @param [in] num_fv_states Number of first-variational states
subroutine sirius_get_fv_eigen_vectors(handler,ik,fv_evec,ld,num_fv_states)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ik
complex(8), intent(out) :: fv_evec
integer, intent(in) :: ld
integer, intent(in) :: num_fv_states
!
!
interface
subroutine sirius_get_fv_eigen_vectors_aux(handler,ik,fv_evec,ld,num_fv_states)&
&bind(C, name="sirius_get_fv_eigen_vectors")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ik
complex(C_DOUBLE), intent(out) :: fv_evec
integer(C_INT), intent(in) :: ld
integer(C_INT), intent(in) :: num_fv_states
end subroutine
end interface

call sirius_get_fv_eigen_vectors_aux(handler,ik,fv_evec,ld,num_fv_states)
end subroutine sirius_get_fv_eigen_vectors

!
!> @brief Get the first-variational eigen values
!> @param [in] handler K-point set handler
!> @param [in] ik Global index of the k-point
!> @param [out] fv_eval Output first-variational eigenvector array
!> @param [in] num_fv_states Number of first-variational states
subroutine sirius_get_fv_eigen_values(handler,ik,fv_eval,num_fv_states)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ik
real(8), intent(out) :: fv_eval
integer, intent(in) :: num_fv_states
!
!
interface
subroutine sirius_get_fv_eigen_values_aux(handler,ik,fv_eval,num_fv_states)&
&bind(C, name="sirius_get_fv_eigen_values")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ik
real(C_DOUBLE), intent(out) :: fv_eval
integer(C_INT), intent(in) :: num_fv_states
end subroutine
end interface

call sirius_get_fv_eigen_values_aux(handler,ik,fv_eval,num_fv_states)
end subroutine sirius_get_fv_eigen_values

!
!> @brief Get the second-variational eigen vectors
!> @param [in] handler K-point set handler
!> @param [in] ik Global index of the k-point
!> @param [out] sv_evec Output second-variational eigenvector array
!> @param [in] num_bands Number of second-variational bands.
subroutine sirius_get_sv_eigen_vectors(handler,ik,sv_evec,num_bands)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ik
complex(8), intent(out) :: sv_evec
integer, intent(in) :: num_bands
!
!
interface
subroutine sirius_get_sv_eigen_vectors_aux(handler,ik,sv_evec,num_bands)&
&bind(C, name="sirius_get_sv_eigen_vectors")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ik
complex(C_DOUBLE), intent(out) :: sv_evec
integer(C_INT), intent(in) :: num_bands
end subroutine
end interface

call sirius_get_sv_eigen_vectors_aux(handler,ik,sv_evec,num_bands)
end subroutine sirius_get_sv_eigen_vectors

!
!> @brief Set the values of the function on the regular grid.
!> @param [in] handler DFT ground state handler.
!> @param [in] label Label of the function.
!> @param [in] grid_dims Dimensions of the FFT grid.
!> @param [in] local_box_origin Coordinates of the local box origin for each MPI rank
!> @param [in] local_box_size Dimensions of the local box for each MPI rank.
!> @param [in] fcomm Fortran communicator used to partition FFT grid into local boxes.
!> @param [in] values Values of the function (local buffer for each MPI rank).
!> @param [in] transform_to_pw If true, transform function to PW domain.
subroutine sirius_set_rg_values(handler,label,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_pw)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: grid_dims
integer, intent(in) :: local_box_origin
integer, intent(in) :: local_box_size
integer, intent(in) :: fcomm
real(8), intent(in) :: values
logical, optional, target, intent(in) :: transform_to_pw
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: transform_to_pw_c_type
type(C_PTR) :: transform_to_pw_ptr
!
interface
subroutine sirius_set_rg_values_aux(handler,label,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_pw)&
&bind(C, name="sirius_set_rg_values")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: grid_dims
integer(C_INT), intent(in) :: local_box_origin
integer(C_INT), intent(in) :: local_box_size
integer(C_INT), intent(in) :: fcomm
real(C_DOUBLE), intent(in) :: values
type(C_PTR), value :: transform_to_pw
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
transform_to_pw_ptr = C_NULL_PTR
if (present(transform_to_pw)) then
  transform_to_pw_c_type = bool(transform_to_pw)
  transform_to_pw_ptr = C_LOC(transform_to_pw_c_type)
endif
call sirius_set_rg_values_aux(handler,label_ptr,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_pw_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_rg_values

!
!> @brief Get the values of the function on the regular grid.
!> @param [in] handler DFT ground state handler.
!> @param [in] label Label of the function.
!> @param [in] grid_dims Dimensions of the FFT grid.
!> @param [in] local_box_origin Coordinates of the local box origin for each MPI rank
!> @param [in] local_box_size Dimensions of the local box for each MPI rank.
!> @param [in] fcomm Fortran communicator used to partition FFT grid into local boxes.
!> @param [out] values Values of the function (local buffer for each MPI rank).
!> @param [in] transform_to_rg If true, transform function to regular grid before fetching the values.
subroutine sirius_get_rg_values(handler,label,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_rg)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
integer, intent(in) :: grid_dims
integer, intent(in) :: local_box_origin
integer, intent(in) :: local_box_size
integer, intent(in) :: fcomm
real(8), intent(out) :: values
logical, optional, target, intent(in) :: transform_to_rg
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
logical(C_BOOL), target :: transform_to_rg_c_type
type(C_PTR) :: transform_to_rg_ptr
!
interface
subroutine sirius_get_rg_values_aux(handler,label,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_rg)&
&bind(C, name="sirius_get_rg_values")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
integer(C_INT), intent(in) :: grid_dims
integer(C_INT), intent(in) :: local_box_origin
integer(C_INT), intent(in) :: local_box_size
integer(C_INT), intent(in) :: fcomm
real(C_DOUBLE), intent(out) :: values
type(C_PTR), value :: transform_to_rg
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
transform_to_rg_ptr = C_NULL_PTR
if (present(transform_to_rg)) then
  transform_to_rg_c_type = bool(transform_to_rg)
  transform_to_rg_ptr = C_LOC(transform_to_rg_c_type)
endif
call sirius_get_rg_values_aux(handler,label_ptr,grid_dims,local_box_origin,local_box_size,&
&fcomm,values,transform_to_rg_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_get_rg_values

!
!> @brief Get the total magnetization of the system.
!> @param [in] handler DFT ground state handler.
!> @param [out] mag 3D magnetization vector (x,y,z components).
subroutine sirius_get_total_magnetization(handler,mag)
implicit none
!
type(C_PTR), intent(in) :: handler
real(8), intent(out) :: mag
!
!
interface
subroutine sirius_get_total_magnetization_aux(handler,mag)&
&bind(C, name="sirius_get_total_magnetization")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
real(C_DOUBLE), intent(out) :: mag
end subroutine
end interface

call sirius_get_total_magnetization_aux(handler,mag)
end subroutine sirius_get_total_magnetization

!
!> @brief Get the total number of kpoints
!> @param [in] handler Kpoint set handler
!> @param [out] num_kpoints number of kpoints in the set
!> @param [out] error_code Error code.
subroutine sirius_get_num_kpoints(handler,num_kpoints,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: num_kpoints
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_num_kpoints_aux(handler,num_kpoints,error_code)&
&bind(C, name="sirius_get_num_kpoints")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: num_kpoints
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_num_kpoints_aux(handler,num_kpoints,error_code_ptr)
end subroutine sirius_get_num_kpoints

!
!> @brief Get the number of computed bands
!> @param [in] handler Simulation context handler.
!> @param [out] num_kpoints Number of kpoints in the set
!> @param [out] error_code Error code.
subroutine sirius_get_num_bands(handler,num_kpoints,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: num_kpoints
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_num_bands_aux(handler,num_kpoints,error_code)&
&bind(C, name="sirius_get_num_bands")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: num_kpoints
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_num_bands_aux(handler,num_kpoints,error_code_ptr)
end subroutine sirius_get_num_bands

!
!> @brief Get the number of spin components
!> @param [in] handler Simulation context handler
!> @param [out] num_spin_components Number of spin components.
!> @param [out] error_code Error code.
subroutine sirius_get_num_spin_components(handler,num_spin_components,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: num_spin_components
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_num_spin_components_aux(handler,num_spin_components,error_code)&
&bind(C, name="sirius_get_num_spin_components")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: num_spin_components
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_num_spin_components_aux(handler,num_spin_components,error_code_ptr)
end subroutine sirius_get_num_spin_components

!
!> @brief Get the kpoint properties
!> @param [in] handler Kpoint set handler
!> @param [in] ik Index of the kpoint
!> @param [out] weight Weight of the kpoint
!> @param [out] coordinates Coordinates of the kpoint
!> @param [out] error_code Error code.
subroutine sirius_get_kpoint_properties(handler,ik,weight,coordinates,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ik
real(8), intent(out) :: weight
real(8), optional, target, intent(out) :: coordinates
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: coordinates_ptr
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_kpoint_properties_aux(handler,ik,weight,coordinates,error_code)&
&bind(C, name="sirius_get_kpoint_properties")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ik
real(C_DOUBLE), intent(out) :: weight
type(C_PTR), value :: coordinates
type(C_PTR), value :: error_code
end subroutine
end interface

coordinates_ptr = C_NULL_PTR
if (present(coordinates)) coordinates_ptr = C_LOC(coordinates)

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_kpoint_properties_aux(handler,ik,weight,coordinates_ptr,error_code_ptr)
end subroutine sirius_get_kpoint_properties

!
!> @brief Get maximum APW basis size across all atoms.
!> @param [in] handler Simulation context handler.
!> @param [out] max_mt_aw_basis_size Maximum APW basis size.
!> @param [out] error_code Error code.
subroutine sirius_get_max_mt_aw_basis_size(handler,max_mt_aw_basis_size,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(out) :: max_mt_aw_basis_size
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_max_mt_aw_basis_size_aux(handler,max_mt_aw_basis_size,error_code)&
&bind(C, name="sirius_get_max_mt_aw_basis_size")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(out) :: max_mt_aw_basis_size
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_max_mt_aw_basis_size_aux(handler,max_mt_aw_basis_size,error_code_ptr)
end subroutine sirius_get_max_mt_aw_basis_size

!
!> @brief Get matching coefficients for all atoms.
!> @details
!> Warning! Generation of matching coefficients for all atoms has a large memory footprint. Use it with caution.
!> @param [in] handler K-point set handler.
!> @param [in] ik Index of k-point.
!> @param [out] alm Matching coefficients.
!> @param [out] error_code Error code.
subroutine sirius_get_matching_coefficients(handler,ik,alm,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
integer, intent(in) :: ik
complex(8), intent(out) :: alm
integer, optional, target, intent(out) :: error_code
!
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_get_matching_coefficients_aux(handler,ik,alm,error_code)&
&bind(C, name="sirius_get_matching_coefficients")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
integer(C_INT), intent(in) :: ik
complex(C_DOUBLE), intent(out) :: alm
type(C_PTR), value :: error_code
end subroutine
end interface

error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_get_matching_coefficients_aux(handler,ik,alm,error_code_ptr)
end subroutine sirius_get_matching_coefficients

!
!> @brief Set callback function to compute various radial integrals.
!> @param [in] handler Simulation context handler.
!> @param [in] label Lable of the callback function.
!> @param [in] fptr Pointer to callback function.
!> @param [out] error_code Error code.
subroutine sirius_set_callback_function(handler,label,fptr,error_code)
implicit none
!
type(C_PTR), intent(in) :: handler
character(*), intent(in) :: label
type(C_FUNPTR), intent(in) :: fptr
integer, optional, target, intent(out) :: error_code
!
character(C_CHAR), target, allocatable :: label_c_type(:)
type(C_PTR) :: label_ptr
type(C_PTR) :: error_code_ptr
!
interface
subroutine sirius_set_callback_function_aux(handler,label,fptr,error_code)&
&bind(C, name="sirius_set_callback_function")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), value :: label
type(C_FUNPTR), value, intent(in) :: fptr
type(C_PTR), value :: error_code
end subroutine
end interface

label_ptr = C_NULL_PTR
allocate(label_c_type(len(label)+1))
label_c_type = string(label)
label_ptr = C_LOC(label_c_type)
error_code_ptr = C_NULL_PTR
if (present(error_code)) error_code_ptr = C_LOC(error_code)

call sirius_set_callback_function_aux(handler,label_ptr,fptr,error_code_ptr)
if (allocated(label_c_type)) deallocate(label_c_type)
end subroutine sirius_set_callback_function

!
!> @brief Robust wave function optimizer
!> @param [in] handler Ground state handler
!> @param [in] ks_handler point set handler
subroutine sirius_nlcg(handler,ks_handler)
implicit none
!
type(C_PTR), intent(in) :: handler
type(C_PTR), intent(in) :: ks_handler
!
!
interface
subroutine sirius_nlcg_aux(handler,ks_handler)&
&bind(C, name="sirius_nlcg")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), intent(in) :: handler
type(C_PTR), intent(in) :: ks_handler
end subroutine
end interface

call sirius_nlcg_aux(handler,ks_handler)
end subroutine sirius_nlcg

